// @ts-ignore

// source: https://themer.sanity.build/api/hues?preset=stereofidelic&caution=fbd024;300&min=0

// Generated 2025-06-28T15:05:12.721Z
// Not minified, remove `?min=0` from the request for much smaller output

// ../../node_modules/.pnpm/@sanity+color@3.0.5/node_modules/@sanity/color/dist/index.js
const COLOR_HUES = [
    'gray',
    'blue',
    'purple',
    'magenta',
    'red',
    'orange',
    'yellow',
    'green',
    'cyan',
  ],
  COLOR_TINTS = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950']
const black = {
    title: 'Black',
    hex: '#0d0e12',
  },
  white = {
    title: 'White',
    hex: '#ffffff',
  },
  gray = {
    50: {
      title: 'Gray 50',
      hex: '#f6f6f8',
    },
    100: {
      title: 'Gray 100',
      hex: '#eeeef1',
    },
    200: {
      title: 'Gray 200',
      hex: '#e3e4e8',
    },
    300: {
      title: 'Gray 300',
      hex: '#bbbdc9',
    },
    400: {
      title: 'Gray 400',
      hex: '#9499ad',
    },
    500: {
      title: 'Gray 500',
      hex: '#727892',
    },
    600: {
      title: 'Gray 600',
      hex: '#515870',
    },
    700: {
      title: 'Gray 700',
      hex: '#383d51',
    },
    800: {
      title: 'Gray 800',
      hex: '#252837',
    },
    900: {
      title: 'Gray 900',
      hex: '#1b1d27',
    },
    950: {
      title: 'Gray 950',
      hex: '#13141b',
    },
  },
  blue = {
    50: {
      title: 'Blue 50',
      hex: '#f5f8ff',
    },
    100: {
      title: 'Blue 100',
      hex: '#e5edff',
    },
    200: {
      title: 'Blue 200',
      hex: '#dbe5ff',
    },
    300: {
      title: 'Blue 300',
      hex: '#a8bfff',
    },
    400: {
      title: 'Blue 400',
      hex: '#7595ff',
    },
    500: {
      title: 'Blue 500',
      hex: '#556bfc',
    },
    600: {
      title: 'Blue 600',
      hex: '#4043e7',
    },
    700: {
      title: 'Blue 700',
      hex: '#2927aa',
    },
    800: {
      title: 'Blue 800',
      hex: '#192457',
    },
    900: {
      title: 'Blue 900',
      hex: '#161a41',
    },
    950: {
      title: 'Blue 950',
      hex: '#101228',
    },
  },
  purple = {
    50: {
      title: 'Purple 50',
      hex: '#f8f5ff',
    },
    100: {
      title: 'Purple 100',
      hex: '#f1ebff',
    },
    200: {
      title: 'Purple 200',
      hex: '#ece1fe',
    },
    300: {
      title: 'Purple 300',
      hex: '#ccb1fc',
    },
    400: {
      title: 'Purple 400',
      hex: '#b087f7',
    },
    500: {
      title: 'Purple 500',
      hex: '#8f57ef',
    },
    600: {
      title: 'Purple 600',
      hex: '#721fe5',
    },
    700: {
      title: 'Purple 700',
      hex: '#4c1a9e',
    },
    800: {
      title: 'Purple 800',
      hex: '#2f1862',
    },
    900: {
      title: 'Purple 900',
      hex: '#23173f',
    },
    950: {
      title: 'Purple 950',
      hex: '#181128',
    },
  },
  magenta = {
    50: {
      title: 'Magenta 50',
      hex: '#fef6f9',
    },
    100: {
      title: 'Magenta 100',
      hex: '#fde8ef',
    },
    200: {
      title: 'Magenta 200',
      hex: '#fcdee9',
    },
    300: {
      title: 'Magenta 300',
      hex: '#f7abc5',
    },
    400: {
      title: 'Magenta 400',
      hex: '#f0709b',
    },
    500: {
      title: 'Magenta 500',
      hex: '#e72767',
    },
    600: {
      title: 'Magenta 600',
      hex: '#b11651',
    },
    700: {
      title: 'Magenta 700',
      hex: '#7c1342',
    },
    800: {
      title: 'Magenta 800',
      hex: '#4b1130',
    },
    900: {
      title: 'Magenta 900',
      hex: '#341325',
    },
    950: {
      title: 'Magenta 950',
      hex: '#1f0f14',
    },
  },
  red = {
    50: {
      title: 'Red 50',
      hex: '#fff6f5',
    },
    100: {
      title: 'Red 100',
      hex: '#ffe7e5',
    },
    200: {
      title: 'Red 200',
      hex: '#ffdedc',
    },
    300: {
      title: 'Red 300',
      hex: '#fdada5',
    },
    400: {
      title: 'Red 400',
      hex: '#f77769',
    },
    500: {
      title: 'Red 500',
      hex: '#ef4434',
    },
    600: {
      title: 'Red 600',
      hex: '#cc2819',
    },
    700: {
      title: 'Red 700',
      hex: '#8b2018',
    },
    800: {
      title: 'Red 800',
      hex: '#4d1714',
    },
    900: {
      title: 'Red 900',
      hex: '#321615',
    },
    950: {
      title: 'Red 950',
      hex: '#1e1011',
    },
  },
  orange = {
    50: {
      title: 'Orange 50',
      hex: '#fff7f0',
    },
    100: {
      title: 'Orange 100',
      hex: '#ffeadb',
    },
    200: {
      title: 'Orange 200',
      hex: '#ffddc7',
    },
    300: {
      title: 'Orange 300',
      hex: '#ffb685',
    },
    400: {
      title: 'Orange 400',
      hex: '#ff8e42',
    },
    500: {
      title: 'Orange 500',
      hex: '#fa6400',
    },
    600: {
      title: 'Orange 600',
      hex: '#b14802',
    },
    700: {
      title: 'Orange 700',
      hex: '#7c3404',
    },
    800: {
      title: 'Orange 800',
      hex: '#461e07',
    },
    900: {
      title: 'Orange 900',
      hex: '#32160b',
    },
    950: {
      title: 'Orange 950',
      hex: '#21120d',
    },
  },
  yellow = {
    50: {
      title: 'Yellow 50',
      hex: '#fefae1',
    },
    100: {
      title: 'Yellow 100',
      hex: '#fcf3bb',
    },
    200: {
      title: 'Yellow 200',
      hex: '#f9e994',
    },
    300: {
      title: 'Yellow 300',
      hex: '#f7d455',
    },
    400: {
      title: 'Yellow 400',
      hex: '#f9bc15',
    },
    500: {
      title: 'Yellow 500',
      hex: '#d28a04',
    },
    600: {
      title: 'Yellow 600',
      hex: '#965908',
    },
    700: {
      title: 'Yellow 700',
      hex: '#653a0b',
    },
    800: {
      title: 'Yellow 800',
      hex: '#3b220c',
    },
    900: {
      title: 'Yellow 900',
      hex: '#271a11',
    },
    950: {
      title: 'Yellow 950',
      hex: '#181410',
    },
  },
  green = {
    50: {
      title: 'Green 50',
      hex: '#e7fef5',
    },
    100: {
      title: 'Green 100',
      hex: '#c5fce8',
    },
    200: {
      title: 'Green 200',
      hex: '#a9f9dc',
    },
    300: {
      title: 'Green 300',
      hex: '#59f3ba',
    },
    400: {
      title: 'Green 400',
      hex: '#0ff0a1',
    },
    500: {
      title: 'Green 500',
      hex: '#04b97a',
    },
    600: {
      title: 'Green 600',
      hex: '#01794f',
    },
    700: {
      title: 'Green 700',
      hex: '#015133',
    },
    800: {
      title: 'Green 800',
      hex: '#023120',
    },
    900: {
      title: 'Green 900',
      hex: '#06231a',
    },
    950: {
      title: 'Green 950',
      hex: '#071715',
    },
  },
  cyan = {
    50: {
      title: 'Cyan 50',
      hex: '#e7fefe',
    },
    100: {
      title: 'Cyan 100',
      hex: '#c5fcfc',
    },
    200: {
      title: 'Cyan 200',
      hex: '#96f8f8',
    },
    300: {
      title: 'Cyan 300',
      hex: '#62efef',
    },
    400: {
      title: 'Cyan 400',
      hex: '#18e2e2',
    },
    500: {
      title: 'Cyan 500',
      hex: '#04b8be',
    },
    600: {
      title: 'Cyan 600',
      hex: '#037782',
    },
    700: {
      title: 'Cyan 700',
      hex: '#024950',
    },
    800: {
      title: 'Cyan 800',
      hex: '#042f34',
    },
    900: {
      title: 'Cyan 900',
      hex: '#072227',
    },
    950: {
      title: 'Cyan 950',
      hex: '#0d181c',
    },
  },
  hues = {gray, blue, purple, magenta, red, orange, yellow, green, cyan},
  color = {black, white, ...hues}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/dist/theme.mjs
const colors = {
  default: {
    lightest: 'hsl(0, 0%, 95%)',
    lighter: 'hsl(0, 0%, 70%)',
    light: 'hsl(0, 0%, 65%)',
    base: 'hsl(0, 0%, 50%)',
    dark: 'hsl(0, 0%, 35%)',
    darker: 'hsl(0, 0%, 20%)',
    darkest: 'hsl(0, 0%, 5%)',
  },
  transparent: {
    lightest: 'hsl(240, 100%, 95%)',
    lighter: 'hsl(240, 100%, 70%)',
    light: 'hsl(240, 100%, 65%)',
    base: 'hsl(240, 100%, 50%)',
    dark: 'hsl(240, 100%, 35%)',
    darker: 'hsl(240, 100%, 20%)',
    darkest: 'hsl(240, 100%, 5%)',
  },
  primary: {
    lightest: 'hsl(240, 100%, 95%)',
    lighter: 'hsl(240, 100%, 70%)',
    light: 'hsl(240, 100%, 65%)',
    base: 'hsl(240, 100%, 50%)',
    dark: 'hsl(240, 100%, 35%)',
    darker: 'hsl(240, 100%, 20%)',
    darkest: 'hsl(240, 100%, 5%)',
  },
  positive: {
    lightest: 'hsl(120, 100%, 95%)',
    lighter: 'hsl(120, 100%, 70%)',
    light: 'hsl(120, 100%, 65%)',
    base: 'hsl(120, 100%, 50%)',
    dark: 'hsl(120, 100%, 35%)',
    darker: 'hsl(120, 100%, 20%)',
    darkest: 'hsl(120, 100%, 5%)',
  },
  caution: {
    lightest: 'hsl(60, 100%, 95%)',
    lighter: 'hsl(60, 100%, 70%)',
    light: 'hsl(60, 100%, 65%)',
    base: 'hsl(60, 100%, 50%)',
    dark: 'hsl(60, 100%, 35%)',
    darker: 'hsl(60, 100%, 20%)',
    darkest: 'hsl(60, 100%, 5%)',
  },
  critical: {
    lightest: 'hsl(0, 100%, 95%)',
    lighter: 'hsl(0, 100%, 70%)',
    light: 'hsl(0, 100%, 65%)',
    base: 'hsl(0, 100%, 50%)',
    dark: 'hsl(0, 100%, 35%)',
    darker: 'hsl(0, 100%, 20%)',
    darkest: 'hsl(0, 100%, 5%)',
  },
}
const tones = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base],
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base],
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base],
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base],
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base],
  },
}
const BORDER_WIDTH = 1,
  OUTLINE_WIDTH = 0.5,
  defaultThemeConfig = {
    _version: 2,
    avatar: {
      sizes: [
        {distance: -4, size: 19},
        {distance: -4, size: 25},
        {distance: -8, size: 33},
        {distance: -12, size: 49},
      ],
      focusRing: {offset: 1, width: 1},
    },
    button: {
      textWeight: 'medium',
      border: {width: BORDER_WIDTH},
      focusRing: {offset: -1, width: 1},
    },
    card: {
      border: {width: BORDER_WIDTH},
      focusRing: {offset: -1, width: 1},
      shadow: {outline: OUTLINE_WIDTH},
    },
    container: [320, 640, 960, 1280, 1600, 1920],
    media: [360, 600, 900, 1200, 1800, 2400],
    layer: {
      dialog: {zOffset: 600},
      popover: {zOffset: 400},
      tooltip: {zOffset: 200},
    },
    radius: [0, 1, 3, 6, 9, 12, 21],
    shadow: [
      null,
      {umbra: [0, 0, 0, 0], penumbra: [0, 0, 0, 0], ambient: [0, 0, 0, 0]},
      {umbra: [0, 3, 5, -2], penumbra: [0, 6, 10, 0], ambient: [0, 1, 18, 1]},
      {umbra: [0, 7, 8, -4], penumbra: [0, 12, 17, 2], ambient: [0, 5, 22, 4]},
      {umbra: [0, 9, 11, -5], penumbra: [0, 18, 28, 2], ambient: [0, 7, 34, 6]},
      {umbra: [0, 11, 15, -7], penumbra: [0, 24, 38, 3], ambient: [0, 9, 46, 8]},
    ],
    space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
    input: {
      border: {
        width: BORDER_WIDTH,
      },
      checkbox: {
        size: 17,
        focusRing: {offset: -1, width: 1},
      },
      radio: {
        size: 17,
        markSize: 9,
        focusRing: {offset: -1, width: 1},
      },
      switch: {
        width: 25,
        height: 17,
        padding: 5,
        transitionDurationMs: 150,
        transitionTimingFunction: 'ease-out',
        focusRing: {offset: 1, width: 1},
      },
      select: {
        focusRing: {offset: -1, width: 1},
      },
      text: {
        focusRing: {offset: -1, width: 1},
      },
    },
    style: {
      button: {
        root: {
          transition: 'background-color 100ms,border-color 100ms,color 100ms',
        },
      },
      // card: {
      //   root: {
      //     transition: 'background-color 100ms,border-color 100ms,color 100ms',
      //   },
      // },
    },
  },
  defaultThemeFonts = {
    code: {
      family: 'ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace',
      weights: {
        regular: 400,
        medium: 500,
        semibold: 600,
        bold: 700,
      },
      sizes: [
        {
          ascenderHeight: 4,
          descenderHeight: 4,
          fontSize: 10,
          iconSize: 17,
          lineHeight: 15,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 5,
          descenderHeight: 5,
          fontSize: 13,
          iconSize: 21,
          lineHeight: 19,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 6,
          descenderHeight: 6,
          fontSize: 16,
          iconSize: 25,
          lineHeight: 23,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 7,
          descenderHeight: 7,
          fontSize: 19,
          iconSize: 29,
          lineHeight: 27,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 8,
          descenderHeight: 8,
          fontSize: 22,
          iconSize: 33,
          lineHeight: 31,
          letterSpacing: 0,
        },
      ],
    },
    heading: {
      family:
        'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
      weights: {
        regular: 700,
        medium: 800,
        semibold: 900,
        bold: 900,
      },
      sizes: [
        {
          ascenderHeight: 5,
          descenderHeight: 5,
          fontSize: 13,
          iconSize: 17,
          lineHeight: 19,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 6,
          descenderHeight: 6,
          fontSize: 16,
          iconSize: 25,
          lineHeight: 23,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 7,
          descenderHeight: 7,
          fontSize: 21,
          iconSize: 33,
          lineHeight: 29,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 8,
          descenderHeight: 8,
          fontSize: 27,
          iconSize: 41,
          lineHeight: 35,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 9.5,
          descenderHeight: 8.5,
          fontSize: 33,
          iconSize: 49,
          lineHeight: 41,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 10.5,
          descenderHeight: 9.5,
          fontSize: 38,
          iconSize: 53,
          lineHeight: 47,
          letterSpacing: 0,
        },
      ],
    },
    label: {
      family:
        'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
      weights: {
        regular: 600,
        medium: 700,
        semibold: 800,
        bold: 900,
      },
      sizes: [
        {
          ascenderHeight: 2,
          descenderHeight: 2,
          fontSize: 8.1,
          iconSize: 13,
          lineHeight: 10,
          letterSpacing: 0.5,
        },
        {
          ascenderHeight: 2,
          descenderHeight: 2,
          fontSize: 9.5,
          iconSize: 15,
          lineHeight: 11,
          letterSpacing: 0.5,
        },
        {
          ascenderHeight: 2,
          descenderHeight: 2,
          fontSize: 10.8,
          iconSize: 17,
          lineHeight: 12,
          letterSpacing: 0.5,
        },
        {
          ascenderHeight: 2,
          descenderHeight: 2,
          fontSize: 12.25,
          iconSize: 19,
          lineHeight: 13,
          letterSpacing: 0.5,
        },
        {
          ascenderHeight: 2,
          descenderHeight: 2,
          fontSize: 13.6,
          iconSize: 21,
          lineHeight: 14,
          letterSpacing: 0.5,
        },
        {
          ascenderHeight: 2,
          descenderHeight: 2,
          fontSize: 15,
          iconSize: 23,
          lineHeight: 15,
          letterSpacing: 0.5,
        },
      ],
    },
    text: {
      family:
        'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
      weights: {
        regular: 400,
        medium: 500,
        semibold: 600,
        bold: 700,
      },
      sizes: [
        {
          ascenderHeight: 4,
          descenderHeight: 4,
          fontSize: 10,
          iconSize: 17,
          lineHeight: 15,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 5,
          descenderHeight: 5,
          fontSize: 13,
          iconSize: 21,
          lineHeight: 19,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 6,
          descenderHeight: 6,
          fontSize: 15,
          iconSize: 25,
          lineHeight: 23,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 7,
          descenderHeight: 7,
          fontSize: 18,
          iconSize: 29,
          lineHeight: 27,
          letterSpacing: 0,
        },
        {
          ascenderHeight: 8,
          descenderHeight: 8,
          fontSize: 21,
          iconSize: 33,
          lineHeight: 31,
          letterSpacing: 0,
        },
      ],
    },
  }
const cache$1 = /* @__PURE__ */ new WeakMap()

function v2_v0(v2) {
  let cachedTheme = cache$1.get(v2)
  if (cachedTheme) return cachedTheme
  let {
    avatar,
    button,
    color: color2,
    container,
    font: fonts,
    input,
    media,
    radius,
    shadow: shadows,
    space,
    style: styles,
  } = v2
  return {
    _version: 0,
    avatar,
    button,
    container,
    color: {
      light: {
        transparent: themeColor_v2_v0(color2.light.transparent),
        default: themeColor_v2_v0(color2.light.default),
        primary: themeColor_v2_v0(color2.light.primary),
        positive: themeColor_v2_v0(color2.light.positive),
        caution: themeColor_v2_v0(color2.light.caution),
        critical: themeColor_v2_v0(color2.light.critical),
      },
      dark: {
        transparent: themeColor_v2_v0(color2.dark.transparent),
        default: themeColor_v2_v0(color2.dark.default),
        primary: themeColor_v2_v0(color2.dark.primary),
        positive: themeColor_v2_v0(color2.dark.positive),
        caution: themeColor_v2_v0(color2.dark.caution),
        critical: themeColor_v2_v0(color2.dark.critical),
      },
    },
    focusRing: input.text.focusRing,
    fonts,
    input,
    media,
    radius,
    shadows,
    space,
    styles,
    v2,
  }
}

function themeColor_v2_v0(color_v2) {
  return {
    base: {
      bg: color_v2.bg,
      fg: color_v2.fg,
      border: color_v2.border,
      focusRing: color_v2.focusRing,
      shadow: color_v2.shadow,
    },
    button: color_v2.button,
    card: color_v2.selectable.default,
    dark: color_v2._dark,
    input: {
      default: inputStatesThemeColor_v2_v0(color_v2.input.default),
      invalid: inputStatesThemeColor_v2_v0(color_v2.input.invalid),
    },
    muted: {
      ...color_v2.button.ghost,
      transparent: color_v2.button.ghost.default,
    },
    solid: {
      ...color_v2.button.default,
      transparent: color_v2.button.default.default,
    },
    selectable: color_v2.selectable,
    spot: {
      gray: color_v2.avatar.gray.bg,
      blue: color_v2.avatar.blue.bg,
      purple: color_v2.avatar.purple.bg,
      magenta: color_v2.avatar.magenta.bg,
      red: color_v2.avatar.red.bg,
      orange: color_v2.avatar.orange.bg,
      yellow: color_v2.avatar.yellow.bg,
      green: color_v2.avatar.green.bg,
      cyan: color_v2.avatar.cyan.bg,
    },
    syntax: color_v2.syntax,
  }
}

function inputStatesThemeColor_v2_v0(t) {
  return {
    enabled: inputStateThemeColor_v2_v0(t.enabled),
    disabled: inputStateThemeColor_v2_v0(t.disabled),
    readOnly: inputStateThemeColor_v2_v0(t.readOnly),
    hovered: inputStateThemeColor_v2_v0(t.hovered),
  }
}

function inputStateThemeColor_v2_v0(t) {
  return {
    bg: t.bg,
    bg2: t.muted.bg,
    border: t.border,
    fg: t.fg,
    placeholder: t.placeholder,
  }
}

const THEME_COLOR_BLEND_MODES = ['multiply', 'screen'],
  THEME_COLOR_CARD_TONES = ['transparent', 'default', 'primary', 'positive', 'caution', 'critical'],
  THEME_COLOR_STATE_TONES = ['default', 'primary', 'positive', 'caution', 'critical'],
  THEME_COLOR_STATES = ['enabled', 'hovered', 'pressed', 'selected', 'disabled'],
  THEME_COLOR_BUTTON_MODES = ['default', 'ghost', 'bleed'],
  THEME_COLOR_INPUT_MODES = ['default', 'invalid'],
  THEME_COLOR_INPUT_STATES = ['enabled', 'hovered', 'readOnly', 'disabled'],
  THEME_COLOR_AVATAR_COLORS = COLOR_HUES

function isColorBlendModeValue(str) {
  return THEME_COLOR_BLEND_MODES.includes(str)
}

function isColorHueKey(str) {
  return COLOR_HUES.includes(str)
}

function isColorTintKey(str) {
  return COLOR_TINTS.includes(str)
}

const COLOR_CONFIG_STATE_KEYS = [
    '_hue',
    'bg',
    'fg',
    'border',
    'focusRing',
    'muted/fg',
    'accent/fg',
    'link/fg',
    'code/bg',
    'code/fg',
    'skeleton/from',
    'skeleton/to',
    'status/dot',
    'status/icon',
  ],
  COLOR_CONFIG_CARD_KEYS = [
    ...COLOR_CONFIG_STATE_KEYS,
    '_hue',
    'bg',
    'fg',
    'border',
    'focusRing',
    'shadow/outline',
    'shadow/umbra',
    'shadow/penumbra',
    'shadow/ambient',
  ]
const COLOR_CONFIG_AVATAR_COLORS = ['*', ...THEME_COLOR_AVATAR_COLORS],
  COLOR_CONFIG_CARD_TONES = ['*', ...THEME_COLOR_CARD_TONES],
  COLOR_CONFIG_STATE_TONES = ['*', ...THEME_COLOR_STATE_TONES],
  COLOR_CONFIG_STATES = ['*', ...THEME_COLOR_STATES],
  COLOR_CONFIG_INPUT_MODES = ['*', ...THEME_COLOR_INPUT_MODES],
  COLOR_CONFIG_INPUT_STATES = ['*', ...THEME_COLOR_INPUT_STATES]

function isColorMixPercentValue(str) {
  return /^\d+%$/.test(str)
}

function parseTokenValue(str) {
  let segments = str.split('/'),
    nextSegment = segments.shift() || '',
    [segment0, segment0mix] = nextSegment.split(' ')
  if (isColorTintKey(segment0)) {
    let tint2 = segment0,
      segment1 = segments.shift() || ''
    if (isColorMixPercentValue(segment0mix)) {
      let mix22 = Number(segment0mix.slice(0, -1)) / 100
      return {
        type: 'color',
        tint: tint2,
        mix: mix22,
      }
    }
    if (isColorOpacityValue(segment1)) {
      let opacity = Number(segment1)
      return {
        type: 'color',
        tint: tint2,
        opacity,
      }
    }
    return {
      type: 'color',
      tint: tint2,
    }
  }
  if (isColorValue(segment0)) {
    let key = segment0,
      segment1 = segments.shift() || ''
    if (isColorMixPercentValue(segment0mix)) {
      let mix22 = Number(segment0mix.slice(0, -1)) / 100
      return {
        type: 'color',
        key,
        mix: mix22,
      }
    }
    if (isColorOpacityValue(segment1)) {
      let opacity = Number(segment1)
      return {
        type: 'color',
        key,
        opacity,
      }
    }
    return {
      type: 'color',
      key,
    }
  }
  if (isColorHueKey(segment0)) {
    let hue = segment0
    nextSegment = segments.shift() || ''
    let [segment1, segment1mix] = nextSegment.split(' ')
    if (isColorTintKey(segment1)) {
      let tint2 = segment1,
        segment2 = segments.shift() || ''
      if (isColorMixPercentValue(segment1mix)) {
        let mix22 = Number(segment1mix.slice(0, -1)) / 100
        return {
          type: 'color',
          hue,
          tint: tint2,
          mix: mix22,
        }
      }
      if (isColorOpacityValue(segment2)) {
        let opacity = Number(segment2)
        return {
          type: 'color',
          hue,
          tint: tint2,
          opacity,
        }
      }
      return {
        type: 'color',
        hue,
        tint: tint2,
      }
    }
    return {
      type: 'hue',
      value: hue,
    }
  }
  if (isColorBlendModeValue(segment0))
    return {
      type: 'blendMode',
      value: segment0,
    }
}

function isColorValue(str) {
  return str === 'black' || str === 'white'
}

function isColorOpacityValue(str) {
  return str === '0' || /^0\.[0-9]+$/.test(str) || str === '1'
}

function compileColorTokenValue(node) {
  let key = ''
  return (
    node.key === 'black' || node.key === 'white'
      ? (key = node.key)
      : (key = ''.concat(node.hue, '/').concat(node.tint)),
    node.mix !== void 0
      ? ''.concat(key, ' ').concat(node.mix * 100, '%')
      : (node.opacity !== void 0 && (key += '/'.concat(node.opacity)), key)
  )
}

const DEFAULT_COLOR_TOKEN_VALUE = ['500', '500']

function resolveColorTokenValue(context, value = DEFAULT_COLOR_TOKEN_VALUE) {
  let {hue, scheme} = context,
    node = parseTokenValue(value[scheme === 'light' ? 0 : 1])
  if (!node || node.type !== 'color') throw new Error('Invalid color token: '.concat(value[0]))
  return compileColorTokenValue({...node, hue: node.hue || hue})
}

const defaultColorTokens = {
  base: {
    '*': {
      _blend: ['multiply', 'screen'],
      accent: {
        fg: ['purple/600', 'purple/400'],
      },
      avatar: {
        '*': {
          _blend: ['screen', 'multiply'],
          bg: ['500', '400'],
          fg: ['white', 'black'],
        },
      },
      backdrop: ['gray/200/0.5', 'black/0.5'],
      badge: {
        '*': {
          bg: ['100', '900'],
          fg: ['600', '400'],
          icon: ['500', '500'],
          dot: ['500', '500'],
        },
        positive: {
          bg: ['200 50%', '900'],
          fg: ['600', '500'],
        },
        caution: {
          bg: ['200 50%', '900'],
          fg: ['600', '500'],
        },
      },
      bg: ['50', '950'],
      border: ['200', '800'],
      code: {
        bg: ['50', '950'],
        fg: ['600', '400'],
      },
      fg: ['800', '200'],
      focusRing: ['blue/500', 'blue/500'],
      icon: ['600', '400'],
      kbd: {
        bg: ['white', 'black'],
        fg: ['600', '400'],
        border: ['200', '800'],
      },
      link: {
        fg: ['blue/600', 'blue/300'],
      },
      muted: {
        bg: ['50', '950'],
        fg: ['700 75%', '300 75%'],
      },
      shadow: {
        outline: ['500/0.3', '500/0.4'],
        umbra: ['gray/500/0.1', 'black/0.2'],
        penumbra: ['gray/500/0.07', 'black/0.14'],
        ambient: ['gray/500/0.06', 'black/0.12'],
      },
      skeleton: {
        from: ['100', '900'],
        to: ['100 50%', '900 50%'],
      },
    },
    transparent: {
      bg: ['50', 'black'],
    },
    default: {
      bg: ['white', '950'],
      fg: ['800', '200'],
      muted: {
        fg: ['600', '400'],
      },
    },
    primary: {_hue: 'blue'},
    positive: {
      _hue: 'green',
      shadow: {outline: ['500/0.4', '500/0.4']},
    },
    caution: {
      _hue: 'yellow',
      shadow: {outline: ['600/0.3', '500/0.4']},
    },
    critical: {_hue: 'red'},
  },
  button: {
    default: {
      '*': {
        '*': {
          _blend: ['screen', 'multiply'],
          accent: {
            fg: ['purple/300', 'purple/700'],
          },
          avatar: {
            '*': {
              _blend: ['multiply', 'screen'],
              bg: ['white', 'black'],
              fg: ['black', 'white'],
            },
          },
          badge: {
            '*': {
              bg: ['900', '100'],
              fg: ['400', '600'],
              dot: ['500', '500'],
              icon: ['500', '500'],
            },
          },
          bg: ['500', '400'],
          border: ['500/0', '400/0'],
          code: {
            bg: ['500 20%', '400 20%'],
            fg: ['200', '600'],
          },
          fg: ['white', 'black'],
          icon: ['100 70%', '900 70%'],
          kbd: {
            bg: ['black', 'white'],
            fg: ['200', '600'],
            border: ['800', '200'],
          },
          link: {
            fg: ['blue/200', 'blue/600'],
          },
          muted: {
            bg: ['950', '50'],
            fg: ['100 70%', '900 70%'],
          },
          skeleton: {
            from: ['900', '100'],
            to: ['900 50%', '100 50%'],
          },
        },
        hovered: {
          bg: ['700', '300'],
          border: ['700/0', '300/0'],
        },
        pressed: {
          bg: ['700', '300'],
        },
        selected: {
          bg: ['700', '300'],
        },
        disabled: {
          _hue: 'gray',
          accent: {
            fg: ['100 70%', '900 70%'],
          },
          badge: {
            '*': {
              bg: ['gray/700', 'gray/300'],
              fg: ['white', 'black'],
              dot: ['white', 'black'],
              icon: ['white', 'black'],
            },
          },
          bg: ['300', '600'],
          fg: ['300', '600'],
          muted: {
            bg: ['300', '600'],
            fg: ['300', '600'],
          },
          kbd: {
            bg: ['black', 'white'],
            fg: ['white', 'black'],
            border: ['700', '300'],
          },
          link: {
            fg: ['100 70%', '900 70%'],
          },
        },
      },
      default: {
        '*': {
          bg: ['800', '200'],
          muted: {
            bg: ['950', '50'],
            fg: ['400', '600'],
          },
        },
        hovered: {
          bg: ['900', '100'],
        },
        pressed: {
          bg: ['black', 'white'],
        },
        selected: {
          bg: ['black', 'white'],
        },
      },
    },
    ghost: {
      '*': {
        '*': {
          _blend: ['multiply', 'screen'],
          accent: {
            fg: ['purple/700 60%', 'purple/300 70%'],
          },
          badge: {
            '*': {
              bg: ['100', '900'],
              fg: ['600', '400'],
              dot: ['500', '500'],
              icon: ['500', '500'],
            },
          },
          bg: ['50', '950'],
          border: ['100', '900'],
          code: {
            bg: ['500 10%', '400 10%'],
            fg: ['700 60%', '400 60%'],
          },
          fg: ['600', '400'],
          icon: ['700 60%', '300 60%'],
          kbd: {
            bg: ['white', 'black'],
            fg: ['600', '400'],
            border: ['200', '800'],
          },
          link: {
            fg: ['blue/700 60%', 'blue/300 60%'],
          },
          muted: {
            bg: ['100', '950'],
            fg: ['700 60%', '300 60%'],
          },
          skeleton: {
            from: ['100', '900'],
            to: ['100 50%', '900 50%'],
          },
        },
        hovered: {
          bg: ['100', '900'],
          fg: ['700', '300'],
        },
        pressed: {
          bg: ['100', '900'],
          fg: ['800', '200'],
        },
        selected: {
          bg: ['100', '900'],
          fg: ['800', '200'],
        },
        disabled: {
          _hue: 'gray',
          accent: {
            fg: ['200', '800'],
          },
          badge: {
            '*': {
              _hue: 'gray',
              bg: ['50', '950'],
              fg: ['gray/200', 'gray/800'],
              dot: ['gray/200', 'gray/800'],
              icon: ['gray/200', 'gray/800'],
            },
          },
          border: ['100', '900'],
          code: {
            bg: ['50', '950'],
            fg: ['200', '800'],
          },
          fg: ['400', '600'],
          icon: ['300', '700'],
          muted: {
            fg: ['400', '600'],
          },
          kbd: {
            bg: ['white', 'black'],
            fg: ['200', '800'],
            border: ['100', '900'],
          },
          link: {
            fg: ['200', '800'],
          },
        },
      },
      positive: {
        '*': {
          border: ['600 20%', '800'],
        },
      },
      caution: {
        '*': {
          border: ['600 20%', '800'],
        },
      },
    },
    bleed: {
      '*': {
        '*': {
          _blend: ['multiply', 'screen'],
          accent: {
            fg: ['purple/700 70%', 'purple/300 70%'],
          },
          badge: {
            '*': {
              bg: ['100', '900'],
              fg: ['600', '400'],
              dot: ['500', '500'],
              icon: ['500', '500'],
            },
          },
          bg: ['white', 'black'],
          border: ['white/0', 'black/0'],
          code: {
            bg: ['50', '950'],
            fg: ['700 75%', '300 75%'],
          },
          fg: ['700', '300'],
          icon: ['700 75%', '300 75%'],
          kbd: {
            bg: ['white', 'black'],
            fg: ['700', '300'],
            border: ['200', '800'],
          },
          link: {
            fg: ['blue/700 70%', 'blue/300 70%'],
          },
          muted: {
            bg: ['100', '950'],
            fg: ['700 75%', '300 75%'],
          },
          skeleton: {
            from: ['100', '900'],
            to: ['100 50%', '900 50%'],
          },
        },
        hovered: {
          bg: ['50', '950'],
          icon: ['700 70%', '400 70%'],
        },
        pressed: {
          bg: ['100', '900'],
          fg: ['800', '200'],
          icon: ['800 70%', '200 70%'],
        },
        selected: {
          bg: ['100', '900'],
          fg: ['800', '200'],
          icon: ['800 60%', '200 60%'],
        },
        disabled: {
          _hue: 'gray',
          accent: {
            fg: ['200', '800'],
          },
          badge: {
            '*': {
              _hue: 'gray',
              bg: ['50', '950'],
              fg: ['gray/200', 'gray/800'],
              dot: ['gray/200', 'gray/800'],
              icon: ['gray/200', 'gray/800'],
            },
          },
          code: {
            bg: ['50', '950'],
            fg: ['200', '800'],
          },
          fg: ['400', '600'],
          icon: ['300', '700'],
          muted: {
            fg: ['400', '600'],
          },
          kbd: {
            bg: ['white', 'black'],
            fg: ['200', '800'],
            border: ['100', '900'],
          },
          link: {
            fg: ['200', '800'],
          },
        },
      },
    },
  },
  input: {
    '*': {
      '*': {
        _blend: ['multiply', 'screen'],
        bg: ['white', 'black'],
        border: ['200', '800'],
        fg: ['black', '200'],
        muted: {
          bg: ['50', '950'],
        },
        placeholder: ['400', '600 50%'],
      },
      hovered: {
        border: ['300', '700'],
      },
      readOnly: {
        bg: ['50', '950'],
        border: ['200', '800'],
        fg: ['800', '200'],
      },
      disabled: {
        fg: ['200', '800'],
        border: ['100', '900'],
      },
    },
    invalid: {
      '*': {
        _hue: 'red',
        bg: ['100', '950'],
      },
    },
  },
  selectable: {
    '*': {
      '*': {
        _blend: ['multiply', 'screen'],
        accent: {
          fg: ['purple/700 70%', 'purple/300 70%'],
        },
        badge: {
          '*': {
            bg: ['100', '900'],
            fg: ['600', '400'],
            dot: ['500', '500'],
            icon: ['500', '500'],
          },
        },
        bg: ['white', 'black'],
        border: ['200', '800'],
        code: {
          bg: ['50', '950'],
          fg: ['600', '400'],
        },
        fg: ['700', '300'],
        icon: ['700 75%', '300 75%'],
        kbd: {
          bg: ['white', 'black'],
          fg: ['600', '400'],
          border: ['200', '800'],
        },
        link: {
          fg: ['blue/700 70%', 'blue/300 70%'],
        },
        muted: {
          bg: ['100', '950'],
          fg: ['700 75%', '300 75%'],
        },
        skeleton: {
          from: ['100', '900'],
          to: ['100 50%', '900 50%'],
        },
      },
      hovered: {
        bg: ['50', '950'],
      },
      pressed: {
        bg: ['100', '900'],
      },
      selected: {
        _blend: ['screen', 'multiply'],
        accent: {
          fg: ['purple/300', 'purple/700'],
        },
        avatar: {
          '*': {
            _blend: ['multiply', 'screen'],
            bg: ['white', 'black'],
            fg: ['black', 'white'],
          },
        },
        badge: {
          '*': {
            bg: ['900', '100'],
            fg: ['400', '600'],
            dot: ['500', '500'],
            icon: ['500', '500'],
          },
        },
        bg: ['500', '400'],
        border: ['500 20%', '400 20%'],
        code: {
          bg: ['500 20%', '400 20%'],
          fg: ['200', '600'],
        },
        fg: ['white', 'black'],
        icon: ['100 70%', '900 70%'],
        kbd: {
          bg: ['black', 'white'],
          fg: ['200', '600'],
          border: ['800', '200'],
        },
        link: {
          fg: ['blue/200', 'blue/600'],
        },
        muted: {
          bg: ['950', '50'],
          fg: ['100 70%', '900 70%'],
        },
        skeleton: {
          from: ['900', '100'],
          to: ['900 50%', '100 50%'],
        },
      },
      disabled: {
        _hue: 'gray',
        accent: {
          fg: ['200', '800'],
        },
        badge: {
          '*': {
            _hue: 'gray',
            bg: ['50', '950'],
            fg: ['gray/200', 'gray/800'],
            dot: ['gray/200', 'gray/800'],
            icon: ['gray/200', 'gray/800'],
          },
        },
        border: ['100', '900'],
        code: {
          bg: ['50', '950'],
          fg: ['200', '800'],
        },
        fg: ['200', '800'],
        icon: ['200', '800'],
        kbd: {
          bg: ['white', 'black'],
          fg: ['200', '800'],
          border: ['100', '900'],
        },
        link: {
          fg: ['200', '800'],
        },
        muted: {
          fg: ['200', '800'],
        },
      },
    },
    default: {
      selected: {
        _hue: 'blue',
      },
    },
    critical: {
      disabled: {
        bg: ['50 50%', '950 50%'],
      },
    },
  },
  syntax: {
    atrule: ['purple/600', 'purple/400'],
    attrName: ['green/600', 'green/400'],
    attrValue: ['yellow/600', 'yellow/400'],
    attribute: ['yellow/600', 'yellow/400'],
    boolean: ['purple/600', 'purple/400'],
    builtin: ['purple/600', 'purple/400'],
    cdata: ['yellow/600', 'yellow/400'],
    char: ['yellow/600', 'yellow/400'],
    class: ['orange/600', 'orange/400'],
    className: ['cyan/600', 'cyan/400'],
    comment: ['gray/400', 'gray/600'],
    constant: ['purple/600', 'purple/400'],
    deleted: ['red/600', 'red/400'],
    entity: ['red/600', 'red/400'],
    function: ['green/600', 'green/400'],
    hexcode: ['blue/600', 'blue/400'],
    id: ['purple/600', 'purple/400'],
    important: ['purple/600', 'purple/400'],
    inserted: ['yellow/600', 'yellow/400'],
    keyword: ['magenta/600', 'magenta/400'],
    number: ['purple/600', 'purple/400'],
    operator: ['magenta/600', 'magenta/400'],
    property: ['blue/600', 'blue/400'],
    pseudoClass: ['yellow/600', 'yellow/400'],
    pseudoElement: ['yellow/600', 'yellow/400'],
    punctuation: ['gray/600', 'gray/400'],
    regex: ['blue/600', 'blue/400'],
    selector: ['red/600', 'red/400'],
    string: ['yellow/600', 'yellow/400'],
    symbol: ['purple/600', 'purple/400'],
    tag: ['red/600', 'red/400'],
    unit: ['orange/600', 'orange/400'],
    url: ['red/600', 'red/400'],
    variable: ['red/600', 'red/400'],
  },
}

function isRecord(value) {
  return !!(value && typeof value == 'object' && !Array.isArray(value))
}

function merge(...records) {
  let _records = records.filter(Boolean)
  return _records.length === 0 ? {} : _records.reduce(_merge, {})
}

function _merge(acc, source) {
  for (let key of Object.keys(source)) {
    let prevValue = acc[key],
      nextValue = source[key]
    isRecord(prevValue) && isRecord(nextValue)
      ? (acc[key] = merge(prevValue, nextValue))
      : (acc[key] = nextValue)
  }
  return acc
}

function resolveColorTokens(inputTokens) {
  let tokens = merge(defaultColorTokens, inputTokens)
  return {
    base: resolveBaseColorTokens(tokens),
    button: resolveButtonColorTokens(tokens),
    input: resolveInputColorTokens(tokens),
    selectable: resolveSelectableColorTokens(tokens),
    syntax: tokens.syntax,
  }
}

function resolveBaseColorTokens(sparseTokens) {
  let tokens = {}
  for (let tone of THEME_COLOR_CARD_TONES) tokens[tone] = resolveBaseColorTones(sparseTokens, tone)
  return tokens
}

function resolveBaseColorTones(inputTokens, tone) {
  const _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _i,
    _j,
    _k,
    _l,
    _m,
    _n,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _A,
    _B,
    _C,
    _D,
    _E,
    _F,
    _G,
    _H,
    _I,
    _J,
    _K,
    _L,
    _M,
    _N,
    _O,
    _P
  let spec = merge(
      (_a = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _a['*'],
      (_b = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _b[tone],
    ),
    hue =
      spec._hue ||
      ((_d = (_c = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _c[tone]) ==
      null
        ? void 0
        : _d._hue) ||
      'gray'
  return {
    ...spec,
    _hue: hue,
    avatar: {
      gray: merge(
        {_hue: 'gray'},
        (_e = spec.avatar) == null ? void 0 : _e['*'],
        (_f = spec.avatar) == null ? void 0 : _f.gray,
      ),
      blue: merge(
        {_hue: 'blue'},
        (_g = spec.avatar) == null ? void 0 : _g['*'],
        (_h = spec.avatar) == null ? void 0 : _h.blue,
      ),
      purple: merge(
        {_hue: 'purple'},
        (_i = spec.avatar) == null ? void 0 : _i['*'],
        (_j = spec.avatar) == null ? void 0 : _j.purple,
      ),
      magenta: merge(
        {_hue: 'magenta'},
        (_k = spec.avatar) == null ? void 0 : _k['*'],
        (_l = spec.avatar) == null ? void 0 : _l.magenta,
      ),
      red: merge(
        {_hue: 'red'},
        (_m = spec.avatar) == null ? void 0 : _m['*'],
        (_n = spec.avatar) == null ? void 0 : _n.red,
      ),
      orange: merge(
        {_hue: 'orange'},
        (_o = spec.avatar) == null ? void 0 : _o['*'],
        (_p = spec.avatar) == null ? void 0 : _p.orange,
      ),
      yellow: merge(
        {_hue: 'yellow'},
        (_q = spec.avatar) == null ? void 0 : _q['*'],
        (_r = spec.avatar) == null ? void 0 : _r.yellow,
      ),
      green: merge(
        {_hue: 'green'},
        (_s = spec.avatar) == null ? void 0 : _s['*'],
        (_t = spec.avatar) == null ? void 0 : _t.green,
      ),
      cyan: merge(
        {_hue: 'cyan'},
        (_u = spec.avatar) == null ? void 0 : _u['*'],
        (_v = spec.avatar) == null ? void 0 : _v.cyan,
      ),
    },
    badge: {
      default: {
        _hue:
          ((_x =
            (_w = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _w.default) ==
          null
            ? void 0
            : _x._hue) || hue,
        ...((_y = spec.badge) == null ? void 0 : _y['*']),
        ...((_z = spec.badge) == null ? void 0 : _z.default),
      },
      primary: {
        _hue:
          ((_B =
            (_A = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _A.primary) ==
          null
            ? void 0
            : _B._hue) || hue,
        ...((_C = spec.badge) == null ? void 0 : _C['*']),
        ...((_D = spec.badge) == null ? void 0 : _D.primary),
      },
      positive: {
        _hue:
          ((_F =
            (_E = inputTokens == null ? void 0 : inputTokens.base) == null
              ? void 0
              : _E.positive) == null
            ? void 0
            : _F._hue) || hue,
        ...((_G = spec.badge) == null ? void 0 : _G['*']),
        ...((_H = spec.badge) == null ? void 0 : _H.positive),
      },
      caution: {
        _hue:
          ((_J =
            (_I = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _I.caution) ==
          null
            ? void 0
            : _J._hue) || hue,
        ...((_K = spec.badge) == null ? void 0 : _K['*']),
        ...((_L = spec.badge) == null ? void 0 : _L.caution),
      },
      critical: {
        _hue:
          ((_N =
            (_M = inputTokens == null ? void 0 : inputTokens.base) == null
              ? void 0
              : _M.critical) == null
            ? void 0
            : _N._hue) || hue,
        ...((_O = spec.badge) == null ? void 0 : _O['*']),
        ...((_P = spec.badge) == null ? void 0 : _P.critical),
      },
    },
  }
}

function resolveButtonColorTokens(inputTokens) {
  let tokens = {}
  for (let mode of THEME_COLOR_BUTTON_MODES)
    tokens[mode] = resolveButtonToneColorTokens(inputTokens, mode)
  return tokens
}

function resolveButtonToneColorTokens(inputTokens, mode) {
  let tokens = {}
  for (let tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveButtonModeColorTokens(inputTokens, mode, tone)
  return tokens
}

function resolveButtonModeColorTokens(inputTokens, mode, tone) {
  let tokens = {}
  for (let state of THEME_COLOR_STATES)
    tokens[state] = resolveButtonStateColorTokens(inputTokens, tone, mode, state)
  return tokens
}

function resolveButtonStateColorTokens(inputTokens, tone, mode, state) {
  const _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _i,
    _j,
    _k,
    _l,
    _m,
    _n,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _A,
    _B,
    _C,
    _D,
    _E,
    _F,
    _G,
    _H,
    _I,
    _J,
    _K,
    _L,
    _M,
    _N,
    _O,
    _P,
    _Q,
    _R,
    _S,
    _T,
    _U,
    _V,
    _W,
    _X,
    _Y,
    _Z
  let spec = merge(
      (_c =
        (_b =
          (_a = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _a[mode]) ==
        null
          ? void 0
          : _b['*']) == null
        ? void 0
        : _c['*'],
      (_f =
        (_e =
          (_d = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _d[mode]) ==
        null
          ? void 0
          : _e[tone]) == null
        ? void 0
        : _f['*'],
      (_i =
        (_h =
          (_g = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _g[mode]) ==
        null
          ? void 0
          : _h['*']) == null
        ? void 0
        : _i[state],
      (_l =
        (_k =
          (_j = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _j[mode]) ==
        null
          ? void 0
          : _k[tone]) == null
        ? void 0
        : _l[state],
    ),
    hue =
      spec._hue ||
      ((_n = (_m = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _m[tone]) ==
      null
        ? void 0
        : _n._hue)
  return {
    ...spec,
    _hue: hue,
    avatar: {
      gray: merge(
        {_hue: 'gray'},
        (_o = spec.avatar) == null ? void 0 : _o['*'],
        (_p = spec.avatar) == null ? void 0 : _p.gray,
      ),
      blue: merge(
        {_hue: 'blue'},
        (_q = spec.avatar) == null ? void 0 : _q['*'],
        (_r = spec.avatar) == null ? void 0 : _r.blue,
      ),
      purple: merge(
        {_hue: 'purple'},
        (_s = spec.avatar) == null ? void 0 : _s['*'],
        (_t = spec.avatar) == null ? void 0 : _t.purple,
      ),
      magenta: merge(
        {_hue: 'magenta'},
        (_u = spec.avatar) == null ? void 0 : _u['*'],
        (_v = spec.avatar) == null ? void 0 : _v.magenta,
      ),
      red: merge(
        {_hue: 'red'},
        (_w = spec.avatar) == null ? void 0 : _w['*'],
        (_x = spec.avatar) == null ? void 0 : _x.red,
      ),
      orange: merge(
        {_hue: 'orange'},
        (_y = spec.avatar) == null ? void 0 : _y['*'],
        (_z = spec.avatar) == null ? void 0 : _z.orange,
      ),
      yellow: merge(
        {_hue: 'yellow'},
        (_A = spec.avatar) == null ? void 0 : _A['*'],
        (_B = spec.avatar) == null ? void 0 : _B.yellow,
      ),
      green: merge(
        {_hue: 'green'},
        (_C = spec.avatar) == null ? void 0 : _C['*'],
        (_D = spec.avatar) == null ? void 0 : _D.green,
      ),
      cyan: merge(
        {_hue: 'cyan'},
        (_E = spec.avatar) == null ? void 0 : _E['*'],
        (_F = spec.avatar) == null ? void 0 : _F.cyan,
      ),
    },
    badge: {
      default: {
        _hue:
          (_H =
            (_G = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _G.default) ==
          null
            ? void 0
            : _H._hue,
        ...((_I = spec.badge) == null ? void 0 : _I['*']),
        ...((_J = spec.badge) == null ? void 0 : _J.default),
      },
      primary: {
        _hue:
          (_L =
            (_K = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _K.primary) ==
          null
            ? void 0
            : _L._hue,
        ...((_M = spec.badge) == null ? void 0 : _M['*']),
        ...((_N = spec.badge) == null ? void 0 : _N.primary),
      },
      positive: {
        _hue:
          (_P =
            (_O = inputTokens == null ? void 0 : inputTokens.base) == null
              ? void 0
              : _O.positive) == null
            ? void 0
            : _P._hue,
        ...((_Q = spec.badge) == null ? void 0 : _Q['*']),
        ...((_R = spec.badge) == null ? void 0 : _R.positive),
      },
      caution: {
        _hue:
          (_T =
            (_S = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _S.caution) ==
          null
            ? void 0
            : _T._hue,
        ...((_U = spec.badge) == null ? void 0 : _U['*']),
        ...((_V = spec.badge) == null ? void 0 : _V.caution),
      },
      critical: {
        _hue:
          (_X =
            (_W = inputTokens == null ? void 0 : inputTokens.base) == null
              ? void 0
              : _W.critical) == null
            ? void 0
            : _X._hue,
        ...((_Y = spec.badge) == null ? void 0 : _Y['*']),
        ...((_Z = spec.badge) == null ? void 0 : _Z.critical),
      },
    },
  }
}

function resolveInputColorTokens(inputTokens) {
  let tokens = {}
  for (let mode of THEME_COLOR_INPUT_MODES)
    tokens[mode] = resolveInputModeColorTokens(inputTokens, mode)
  return tokens
}

function resolveInputModeColorTokens(inputTokens, mode) {
  let states = {}
  for (let state of THEME_COLOR_INPUT_STATES)
    states[state] = resolveInputStateColorTokens(inputTokens, mode, state)
  return states
}

function resolveInputStateColorTokens(inputTokens, mode, state) {
  const _a, _b, _c, _d, _e, _f, _g, _h, _i, _j
  let spec = merge(
      (_b = (_a = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _a['*']) ==
        null
        ? void 0
        : _b['*'],
      (_d = (_c = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _c[mode]) ==
        null
        ? void 0
        : _d['*'],
      (_f = (_e = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _e['*']) ==
        null
        ? void 0
        : _f[state],
      (_h = (_g = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _g[mode]) ==
        null
        ? void 0
        : _h[state],
    ),
    hue =
      spec._hue ||
      ((_j = (_i = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _i[mode]) ==
      null
        ? void 0
        : _j._hue)
  return {...spec, _hue: hue}
}

function resolveSelectableColorTokens(inputTokens) {
  let tokens = {}
  for (let tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveSelectableToneColorTokens(inputTokens, tone)
  return tokens
}

function resolveSelectableToneColorTokens(inputTokens, tone) {
  const _a, _b, _c, _d
  let states = {
    _hue:
      ((_b =
        (_a = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _a[tone]) ==
      null
        ? void 0
        : _b._hue) ||
      ((_d = (_c = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _c[tone]) ==
      null
        ? void 0
        : _d._hue),
  }
  for (let state of THEME_COLOR_STATES)
    states[state] = resolveSelectableStateColorTokens(inputTokens, tone, state)
  return states
}

function resolveSelectableStateColorTokens(inputTokens, tone, state) {
  const _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _i,
    _j,
    _k,
    _l,
    _m,
    _n,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _A,
    _B,
    _C,
    _D,
    _E,
    _F,
    _G,
    _H,
    _I,
    _J,
    _K,
    _L,
    _M,
    _N,
    _O,
    _P,
    _Q,
    _R,
    _S,
    _T,
    _U,
    _V
  let spec = merge(
      (_b =
        (_a = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _a['*']) ==
        null
        ? void 0
        : _b['*'],
      (_d =
        (_c = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _c[tone]) ==
        null
        ? void 0
        : _d['*'],
      (_f =
        (_e = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _e['*']) ==
        null
        ? void 0
        : _f[state],
      (_h =
        (_g = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _g[tone]) ==
        null
        ? void 0
        : _h[state],
    ),
    hue =
      spec._hue ||
      ((_j = (_i = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _i[tone]) ==
      null
        ? void 0
        : _j._hue)
  return {
    ...spec,
    _hue: hue,
    avatar: {
      gray: merge(
        {_hue: 'gray'},
        (_k = spec.avatar) == null ? void 0 : _k['*'],
        (_l = spec.avatar) == null ? void 0 : _l.gray,
      ),
      blue: merge(
        {_hue: 'blue'},
        (_m = spec.avatar) == null ? void 0 : _m['*'],
        (_n = spec.avatar) == null ? void 0 : _n.blue,
      ),
      purple: merge(
        {_hue: 'purple'},
        (_o = spec.avatar) == null ? void 0 : _o['*'],
        (_p = spec.avatar) == null ? void 0 : _p.purple,
      ),
      magenta: merge(
        {_hue: 'magenta'},
        (_q = spec.avatar) == null ? void 0 : _q['*'],
        (_r = spec.avatar) == null ? void 0 : _r.magenta,
      ),
      red: merge(
        {_hue: 'red'},
        (_s = spec.avatar) == null ? void 0 : _s['*'],
        (_t = spec.avatar) == null ? void 0 : _t.red,
      ),
      orange: merge(
        {_hue: 'orange'},
        (_u = spec.avatar) == null ? void 0 : _u['*'],
        (_v = spec.avatar) == null ? void 0 : _v.orange,
      ),
      yellow: merge(
        {_hue: 'yellow'},
        (_w = spec.avatar) == null ? void 0 : _w['*'],
        (_x = spec.avatar) == null ? void 0 : _x.yellow,
      ),
      green: merge(
        {_hue: 'green'},
        (_y = spec.avatar) == null ? void 0 : _y['*'],
        (_z = spec.avatar) == null ? void 0 : _z.green,
      ),
      cyan: merge(
        {_hue: 'cyan'},
        (_A = spec.avatar) == null ? void 0 : _A['*'],
        (_B = spec.avatar) == null ? void 0 : _B.cyan,
      ),
    },
    badge: {
      default: {
        _hue:
          (_D =
            (_C = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _C.default) ==
          null
            ? void 0
            : _D._hue,
        ...((_E = spec.badge) == null ? void 0 : _E['*']),
        ...((_F = spec.badge) == null ? void 0 : _F.default),
      },
      primary: {
        _hue:
          (_H =
            (_G = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _G.primary) ==
          null
            ? void 0
            : _H._hue,
        ...((_I = spec.badge) == null ? void 0 : _I['*']),
        ...((_J = spec.badge) == null ? void 0 : _J.primary),
      },
      positive: {
        _hue:
          (_L =
            (_K = inputTokens == null ? void 0 : inputTokens.base) == null
              ? void 0
              : _K.positive) == null
            ? void 0
            : _L._hue,
        ...((_M = spec.badge) == null ? void 0 : _M['*']),
        ...((_N = spec.badge) == null ? void 0 : _N.positive),
      },
      caution: {
        _hue:
          (_P =
            (_O = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _O.caution) ==
          null
            ? void 0
            : _P._hue,
        ...((_Q = spec.badge) == null ? void 0 : _Q['*']),
        ...((_R = spec.badge) == null ? void 0 : _R.caution),
      },
      critical: {
        _hue:
          (_T =
            (_S = inputTokens == null ? void 0 : inputTokens.base) == null
              ? void 0
              : _S.critical) == null
            ? void 0
            : _T._hue,
        ...((_U = spec.badge) == null ? void 0 : _U['*']),
        ...((_V = spec.badge) == null ? void 0 : _V.critical),
      },
    },
  }
}

function buildColorTheme(config) {
  let resolvedConfig = {
    ...config,
    color: resolveColorTokens(config == null ? void 0 : config.color),
  }
  return {
    light: buildColorScheme({scheme: 'light'}, resolvedConfig),
    dark: buildColorScheme({scheme: 'dark'}, resolvedConfig),
  }
}

function buildColorScheme(options, config) {
  let {scheme} = options
  return {
    transparent: buildCardColorTheme({scheme, tone: 'transparent'}, config),
    default: buildCardColorTheme({scheme, tone: 'default'}, config),
    primary: buildCardColorTheme({scheme, tone: 'primary'}, config),
    positive: buildCardColorTheme({scheme, tone: 'positive'}, config),
    caution: buildCardColorTheme({scheme, tone: 'caution'}, config),
    critical: buildCardColorTheme({scheme, tone: 'critical'}, config),
  }
}

function buildCardColorTheme(options, config) {
  const _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m
  let {scheme, tone} = options,
    tokens =
      (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null
        ? void 0
        : _b[tone],
    context = {hue: (tokens == null ? void 0 : tokens._hue) || 'gray', scheme}
  return {
    _blend: ((tokens == null ? void 0 : tokens._blend) || ['multiply', 'screen'])[
      scheme === 'light' ? 0 : 1
    ],
    _dark: scheme === 'dark',
    accent: {
      fg: resolveColorTokenValue(
        context,
        (_c = tokens == null ? void 0 : tokens.accent) == null ? void 0 : _c.fg,
      ),
    },
    avatar: buildAvatarColorTheme({scheme}, tokens),
    backdrop: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.backdrop),
    badge: buildBadgeColorTheme(tokens == null ? void 0 : tokens.badge, {scheme}, config),
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    button: buildButtonColorTheme({scheme}, config),
    code: {
      bg: resolveColorTokenValue(
        context,
        (_d = tokens == null ? void 0 : tokens.code) == null ? void 0 : _d.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_e = tokens == null ? void 0 : tokens.code) == null ? void 0 : _e.fg,
      ),
    },
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    focusRing: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.focusRing),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
    input: buildInputColorTheme({scheme, tone}, config),
    kbd: {
      bg: resolveColorTokenValue(
        context,
        (_f = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _f.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_g = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _g.fg,
      ),
      border: resolveColorTokenValue(
        context,
        (_h = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _h.border,
      ),
    },
    link: {
      fg: resolveColorTokenValue(
        context,
        (_i = tokens == null ? void 0 : tokens.link) == null ? void 0 : _i.fg,
      ),
    },
    muted: {
      bg: resolveColorTokenValue(
        context,
        (_j = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _j.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_k = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _k.fg,
      ),
    },
    selectable: buildSelectableColorTheme({scheme}, config),
    shadow: buildShadowColorTheme({scheme, tone}, config),
    skeleton: {
      from: resolveColorTokenValue(
        context,
        (_l = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _l.from,
      ),
      to: resolveColorTokenValue(
        context,
        (_m = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _m.to,
      ),
    },
    syntax: buildSyntaxColorTheme({scheme}, config),
  }
}

function buildShadowColorTheme(options, config) {
  const _a, _b, _c, _d, _e, _f
  let {scheme, tone} = options,
    tokens =
      (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null
        ? void 0
        : _b[tone],
    context = {hue: (tokens == null ? void 0 : tokens._hue) || 'gray', scheme}
  return {
    outline: resolveColorTokenValue(
      context,
      (_c = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _c.outline,
    ),
    umbra: resolveColorTokenValue(
      context,
      (_d = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _d.umbra,
    ),
    penumbra: resolveColorTokenValue(
      context,
      (_e = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _e.penumbra,
    ),
    ambient: resolveColorTokenValue(
      context,
      (_f = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _f.ambient,
    ),
  }
}

function buildAvatarColorTheme(options, stateTokens) {
  let {scheme} = options
  return {
    gray: _buildAvatarColorTheme({color: 'gray', scheme}, stateTokens),
    blue: _buildAvatarColorTheme({color: 'blue', scheme}, stateTokens),
    purple: _buildAvatarColorTheme({color: 'purple', scheme}, stateTokens),
    magenta: _buildAvatarColorTheme({color: 'magenta', scheme}, stateTokens),
    red: _buildAvatarColorTheme({color: 'red', scheme}, stateTokens),
    orange: _buildAvatarColorTheme({color: 'orange', scheme}, stateTokens),
    yellow: _buildAvatarColorTheme({color: 'yellow', scheme}, stateTokens),
    green: _buildAvatarColorTheme({color: 'green', scheme}, stateTokens),
    cyan: _buildAvatarColorTheme({color: 'cyan', scheme}, stateTokens),
  }
}

function _buildAvatarColorTheme(options, stateTokens) {
  const _a
  let {color: color2, scheme} = options,
    tokens = (_a = stateTokens == null ? void 0 : stateTokens.avatar) == null ? void 0 : _a[color2],
    context = {hue: (tokens == null ? void 0 : tokens._hue) || 'gray', scheme}
  return {
    _blend: ((tokens == null ? void 0 : tokens._blend) || ['screen', 'multiply'])[
      scheme === 'light' ? 0 : 1
    ],
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
  }
}

function buildBadgeColorTheme(tokens, options, config) {
  let {scheme} = options
  return {
    default: _buildBadgeColorTheme(tokens, {scheme, tone: 'default'}, config),
    primary: _buildBadgeColorTheme(tokens, {scheme, tone: 'primary'}, config),
    positive: _buildBadgeColorTheme(tokens, {scheme, tone: 'positive'}, config),
    caution: _buildBadgeColorTheme(tokens, {scheme, tone: 'caution'}, config),
    critical: _buildBadgeColorTheme(tokens, {scheme, tone: 'critical'}, config),
  }
}

function _buildBadgeColorTheme(parentTokens, options, config) {
  const _a, _b, _c
  let {scheme, tone} = options,
    tokens = parentTokens == null ? void 0 : parentTokens[tone],
    context = {
      hue:
        (tokens == null ? void 0 : tokens._hue) ||
        ((_c =
          (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null
            ? void 0
            : _b[tone]) == null
          ? void 0
          : _c._hue) ||
        'gray',
      scheme,
    }
  return {
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    dot: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.dot),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
  }
}

function buildButtonColorTheme(options, config) {
  let {scheme} = options,
    modes = {}
  for (let mode of THEME_COLOR_BUTTON_MODES)
    modes[mode] = buildButtonTonesColorTheme({scheme, mode}, config)
  return modes
}

function buildButtonTonesColorTheme(options, config) {
  let {mode, scheme} = options,
    tones22 = {}
  for (let tone of THEME_COLOR_STATE_TONES)
    tones22[tone] = buildButtonStatesColorTheme({mode, scheme, tone}, config)
  return tones22
}

function buildButtonStatesColorTheme(options, config) {
  let {mode, scheme, tone} = options,
    states = {}
  for (let state of THEME_COLOR_STATES)
    states[state] = buildButtonStateColorTheme({mode, tone, scheme, state}, config)
  return states
}

function buildButtonStateColorTheme(options, config) {
  const _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o
  let {mode, tone, scheme, state} = options,
    tokens =
      (_d =
        (_c =
          (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.button) == null
            ? void 0
            : _b[mode]) == null
          ? void 0
          : _c[tone]) == null
        ? void 0
        : _d[state],
    hue = (tokens == null ? void 0 : tokens._hue) || 'gray',
    blendMode = (tokens == null ? void 0 : tokens._blend) || ['screen', 'multiply'],
    context = {hue, scheme}
  return {
    _blend: blendMode[scheme === 'light' ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(
        context,
        (_e = tokens == null ? void 0 : tokens.accent) == null ? void 0 : _e.fg,
      ),
    },
    avatar: buildAvatarColorTheme({scheme}, tokens),
    badge: buildBadgeColorTheme(tokens == null ? void 0 : tokens.badge, {scheme}, config),
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    code: {
      bg: resolveColorTokenValue(
        context,
        (_f = tokens == null ? void 0 : tokens.code) == null ? void 0 : _f.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_g = tokens == null ? void 0 : tokens.code) == null ? void 0 : _g.fg,
      ),
    },
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
    muted: {
      bg: resolveColorTokenValue(
        context,
        (_h = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _h.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_i = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _i.fg,
      ),
    },
    kbd: {
      bg: resolveColorTokenValue(
        context,
        (_j = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _j.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_k = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _k.fg,
      ),
      border: resolveColorTokenValue(
        context,
        (_l = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _l.border,
      ),
    },
    link: {
      fg: resolveColorTokenValue(
        context,
        (_m = tokens == null ? void 0 : tokens.link) == null ? void 0 : _m.fg,
      ),
    },
    skeleton: {
      from: resolveColorTokenValue(
        context,
        (_n = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _n.from,
      ),
      to: resolveColorTokenValue(
        context,
        (_o = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _o.to,
      ),
    },
  }
}

function buildInputColorTheme(options, config) {
  let {scheme, tone} = options
  return {
    default: buildInputStatesColorTheme({mode: 'default', scheme, tone}, config),
    invalid: buildInputStatesColorTheme({mode: 'invalid', scheme, tone}, config),
  }
}

function buildInputStatesColorTheme(options, config) {
  let {mode, scheme, tone} = options
  return {
    enabled: buildInputStateColorTheme({mode, scheme, state: 'enabled', tone}, config),
    hovered: buildInputStateColorTheme({mode, scheme, state: 'hovered', tone}, config),
    readOnly: buildInputStateColorTheme({mode, scheme, state: 'readOnly', tone}, config),
    disabled: buildInputStateColorTheme({mode, scheme, state: 'disabled', tone}, config),
  }
}

function buildInputStateColorTheme(options, config) {
  const _a, _b, _c, _d, _e, _f, _g
  let {mode, tone, scheme, state} = options,
    tokens =
      (_c =
        (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.input) == null
          ? void 0
          : _b[mode]) == null
        ? void 0
        : _c[state],
    hue =
      (tokens == null ? void 0 : tokens._hue) ||
      ((_f =
        (_e = (_d = config == null ? void 0 : config.color) == null ? void 0 : _d.base) == null
          ? void 0
          : _e[tone]) == null
        ? void 0
        : _f._hue) ||
      'gray',
    blendMode = (tokens == null ? void 0 : tokens._blend) || ['screen', 'multiply'],
    context = {hue, scheme}
  return {
    _blend: blendMode[scheme === 'light' ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    muted: {
      bg: resolveColorTokenValue(
        context,
        (_g = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _g.bg,
      ),
    },
    placeholder: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.placeholder),
  }
}

function buildSelectableColorTheme(options, config) {
  let {scheme} = options,
    tones22 = {}
  for (let tone of THEME_COLOR_STATE_TONES)
    tones22[tone] = buildSelectableStatesColorTheme({scheme, tone}, config)
  return tones22
}

function buildSelectableStatesColorTheme(options, config) {
  let {scheme, tone} = options,
    states = {}
  for (let state of THEME_COLOR_STATES)
    states[state] = buildSelectableStateColorTheme({tone, scheme, state}, config)
  return states
}

function buildSelectableStateColorTheme(options, config) {
  const _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n
  let {scheme, state, tone} = options,
    tokens =
      (_c =
        (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.selectable) ==
        null
          ? void 0
          : _b[tone]) == null
        ? void 0
        : _c[state],
    hue = (tokens == null ? void 0 : tokens._hue) || 'gray',
    blendMode = (tokens == null ? void 0 : tokens._blend) || ['screen', 'multiply'],
    context = {hue, scheme}
  return {
    _blend: blendMode[scheme === 'light' ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(
        context,
        (_d = tokens == null ? void 0 : tokens.accent) == null ? void 0 : _d.fg,
      ),
    },
    avatar: buildAvatarColorTheme({scheme}, tokens),
    badge: buildBadgeColorTheme(tokens == null ? void 0 : tokens.badge, {scheme}, config),
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    code: {
      bg: resolveColorTokenValue(
        context,
        (_e = tokens == null ? void 0 : tokens.code) == null ? void 0 : _e.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_f = tokens == null ? void 0 : tokens.code) == null ? void 0 : _f.fg,
      ),
    },
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
    muted: {
      bg: resolveColorTokenValue(
        context,
        (_g = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _g.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_h = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _h.fg,
      ),
    },
    kbd: {
      bg: resolveColorTokenValue(
        context,
        (_i = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _i.bg,
      ),
      fg: resolveColorTokenValue(
        context,
        (_j = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _j.fg,
      ),
      border: resolveColorTokenValue(
        context,
        (_k = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _k.border,
      ),
    },
    link: {
      fg: resolveColorTokenValue(
        context,
        (_l = tokens == null ? void 0 : tokens.link) == null ? void 0 : _l.fg,
      ),
    },
    skeleton: {
      from: resolveColorTokenValue(
        context,
        (_m = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _m.from,
      ),
      to: resolveColorTokenValue(
        context,
        (_n = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _n.to,
      ),
    },
  }
}

function buildSyntaxColorTheme(options, config) {
  const _a
  let {scheme} = options,
    tokens = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.syntax,
    context = {hue: 'gray', scheme}
  return {
    atrule: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.atrule),
    attrName: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.attrName),
    attrValue: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.attrValue),
    attribute: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.attribute),
    boolean: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.boolean),
    builtin: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.builtin),
    cdata: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.cdata),
    char: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.char),
    class: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.class),
    className: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.className),
    comment: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.comment),
    constant: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.constant),
    deleted: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.deleted),
    doctype: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.doctype),
    entity: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.entity),
    function: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.function),
    hexcode: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.hexcode),
    id: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.id),
    important: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.important),
    inserted: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.inserted),
    keyword: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.keyword),
    number: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.number),
    operator: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.operator),
    prolog: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.prolog),
    property: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.property),
    pseudoClass: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.pseudoClass),
    pseudoElement: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.pseudoElement),
    punctuation: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.punctuation),
    regex: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.regex),
    selector: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.selector),
    string: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.string),
    symbol: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.symbol),
    tag: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.tag),
    unit: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.unit),
    url: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.url),
    variable: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.variable),
  }
}

const defaultColorPalette = color

function mixChannel(b, s, weight) {
  let delta = (s - b) * weight
  return b + delta
}

function mix(b, s, weight) {
  return {
    r: mixChannel(b.r, s.r, weight),
    g: mixChannel(b.g, s.g, weight),
    b: mixChannel(b.b, s.b, weight),
  }
}

function multiplyChannel(b, s) {
  return b * s
}

function multiply(b, s) {
  return {
    r: multiplyChannel(b.r / 255, s.r / 255) * 255,
    g: multiplyChannel(b.g / 255, s.g / 255) * 255,
    b: multiplyChannel(b.b / 255, s.b / 255) * 255,
  }
}

function screenChannel(b, s) {
  return b + s - b * s
}

function screen(b, s) {
  return {
    r: screenChannel(b.r / 255, s.r / 255) * 255,
    g: screenChannel(b.g / 255, s.g / 255) * 255,
    b: screenChannel(b.b / 255, s.b / 255) * 255,
  }
}

function lerp(x, y, a) {
  return x * (1 - a) + y * a
}

function invlerp(x, y, a) {
  return clamp((a - x) / (y - x))
}

function clamp(a, min = 0, max = 1) {
  return Math.min(max, Math.max(min, a))
}

function range(x1, y1, x2, y2, a) {
  return lerp(x2, y2, invlerp(x1, y1, a))
}

function round(value) {
  return Math.round(value)
}

function hexToRgb(hex) {
  if (hex.length === 4) {
    let hexR = hex.slice(1, 2),
      hexG = hex.slice(2, 3),
      hexB = hex.slice(3, 4)
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16),
    }
  }
  return {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16),
  }
}

function rgbaToRGBA(rgba22) {
  let values = rgba22.replace(/rgba\(|\)/g, '').split(',')
  return {
    r: parseInt(values[0]),
    g: parseInt(values[1]),
    b: parseInt(values[2]),
    a: parseFloat(values[3]),
  }
}

function rgbToHex(color2) {
  let r = round(clamp(Math.round(color2.r), 0, 255)),
    g = round(clamp(Math.round(color2.g), 0, 255)),
    b = round(clamp(Math.round(color2.b), 0, 255))
  return 'a' in color2
    ? 'rgba('.concat(r, ',').concat(g, ',').concat(b, ',').concat(color2.a, ')')
    : '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
}

function hslToRgb(hsl2) {
  let s = hsl2.s / 100,
    l = hsl2.l / 100,
    c = (1 - Math.abs(2 * l - 1)) * s,
    x = c * (1 - Math.abs(((hsl2.h / 60) % 2) - 1)),
    m = l - c / 2,
    r = 0,
    g = 0,
    b = 0
  return (
    0 <= hsl2.h && hsl2.h < 60
      ? ((r = c), (g = x), (b = 0))
      : 60 <= hsl2.h && hsl2.h < 120
        ? ((r = x), (g = c), (b = 0))
        : 120 <= hsl2.h && hsl2.h < 180
          ? ((r = 0), (g = c), (b = x))
          : 180 <= hsl2.h && hsl2.h < 240
            ? ((r = 0), (g = x), (b = c))
            : 240 <= hsl2.h && hsl2.h < 300
              ? ((r = x), (g = 0), (b = c))
              : 300 <= hsl2.h && hsl2.h < 360 && ((r = c), (g = 0), (b = x)),
    {
      r: Math.round((r + m) * 255),
      g: Math.round((g + m) * 255),
      b: Math.round((b + m) * 255),
    }
  )
}

const HEX_CHARS = '0123456789ABCDEFabcdef',
  HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i

function isHexChars(str) {
  for (let c of str) if (HEX_CHARS.indexOf(c) === -1) return !1
  return !0
}

function isHex(str) {
  return str[0] !== '#' || !(str.length === 4 || str.length === 7) ? !1 : isHexChars(str.slice(1))
}

function parseHsl(str) {
  let res = HSL_RE.exec(str)
  if (!res) throw new Error('parseHsl: string is not a HSL color: "'.concat(str, '"'))
  return {h: parseInt(res[1]), s: parseFloat(res[3]), l: parseFloat(res[5])}
}

function parseColor(color2) {
  if (!color2) return {r: 0, g: 0, b: 0}
  if (typeof color2 != 'string') throw new Error('parseColor: expected a string')
  if (isHex(color2)) return hexToRgb(color2)
  if (color2.startsWith('hsl(')) return hslToRgb(parseHsl(color2))
  if (color2.startsWith('rgba(')) return rgbaToRGBA(color2)
  throw new Error('parseColor: unexpected color format: "'.concat(color2, '"'))
}

function rgba(color2, a) {
  let rgb2 = parseColor(color2)
  return 'rgba('.concat(rgb2.r, ',').concat(rgb2.g, ',').concat(rgb2.b, ',').concat(a, ')')
}

const RGB_RANGE = [0, 255]

function mixThemeColor(value, options) {
  let {blendMode} = options,
    color2 = parseColor(value),
    black22 = parseColor(options.black),
    white22 = parseColor(options.white),
    bg = options.bg ? parseColor(options.bg) : blendMode === 'multiply' ? white22 : black22,
    paletteRange = {
      r: [black22.r, white22.r],
      g: [black22.g, white22.g],
      b: [black22.b, white22.b],
    },
    convertedBgColor = {
      r: clamp(range(...paletteRange.r, ...RGB_RANGE, bg.r), ...RGB_RANGE),
      g: clamp(range(...paletteRange.g, ...RGB_RANGE, bg.g), ...RGB_RANGE),
      b: clamp(range(...paletteRange.b, ...RGB_RANGE, bg.b), ...RGB_RANGE),
    },
    convertedColor = {
      r: clamp(range(...paletteRange.r, ...RGB_RANGE, color2.r), ...RGB_RANGE),
      g: clamp(range(...paletteRange.g, ...RGB_RANGE, color2.g), ...RGB_RANGE),
      b: clamp(range(...paletteRange.b, ...RGB_RANGE, color2.b), ...RGB_RANGE),
    },
    resultColor =
      blendMode === 'multiply'
        ? multiply(convertedBgColor, convertedColor)
        : screen(convertedBgColor, convertedColor),
    v = {
      r: clamp(range(...RGB_RANGE, ...paletteRange.r, resultColor.r), ...paletteRange.r),
      g: clamp(range(...RGB_RANGE, ...paletteRange.g, resultColor.g), ...paletteRange.g),
      b: clamp(range(...RGB_RANGE, ...paletteRange.b, resultColor.b), ...paletteRange.b),
    }
  return rgbToHex(v)
}

function renderColorValue(str, options) {
  let {bg, blendMode, colorPalette} = options
  if (bg === 'white') throw new Error('Cannot blend with white background')
  let node = parseTokenValue(str)
  if (!node || node.type !== 'color') throw new Error('Invalid color token value: '.concat(str))
  let hex = ''
  if (
    (node.key === 'black' && (hex = renderColorHex(colorPalette.black)),
    node.key === 'white' && (hex = renderColorHex(colorPalette.white)),
    node.hue && node.tint && (hex = renderColorHex(colorPalette[node.hue][node.tint])),
    !hex)
  )
    throw new Error('Invalid color token value: '.concat(str))
  let hexBeforeMix = hex,
    mixOptions = {
      blendMode,
      bg,
      black: renderColorHex(colorPalette.black),
      // opacity: node.opacity,
      white: renderColorHex(colorPalette.white),
    }
  try {
    if (((hex = mixThemeColor(hex, mixOptions)), bg && node.mix !== void 0)) {
      let from = hexToRgb(bg),
        to = hexToRgb(hex)
      hex = rgbToHex(mix(from, to, node.mix))
    }
  } catch (err) {
    throw (console.warn('could not blend', hex, mixOptions), err)
  }
  return (
    hex === '#aN' &&
      (console.warn('invalid color token value: '.concat(str)), (hex = hexBeforeMix)),
    node.opacity !== void 0 && (hex = rgba(hex, node.opacity)),
    hex
  )
}

function renderColorHex(color2) {
  return typeof color2 == 'string' ? color2 : color2.hex
}

function renderThemeColorSchemes(value, config) {
  const _a
  let colorPalette =
    (_a = config == null ? void 0 : config.palette) != null ? _a : defaultColorPalette
  return {
    light: renderThemeColorScheme(colorPalette, value.light),
    dark: renderThemeColorScheme(colorPalette, value.dark),
  }
}

function renderThemeColorScheme(colorPalette, value) {
  let toneEntries = Object.entries(value),
    [, transparentTone] = toneEntries.find(([k]) => k === 'transparent'),
    [, defaultTone] = toneEntries.find(([k]) => k === 'default'),
    renderedTransparentTone = renderThemeColor(transparentTone, {colorPalette}),
    renderedDefaultTone = renderThemeColor(defaultTone, {colorPalette}),
    bg = renderedDefaultTone.bg
  if (bg === 'white') throw new Error('Cannot blend with white background')
  return Object.fromEntries([
    ['transparent', renderedTransparentTone],
    ['default', renderedDefaultTone],
    ...toneEntries
      .filter(([k]) => k !== 'default' && k !== 'transparent')
      .map(([k, v]) => [
        k,
        renderThemeColor(v, {
          bg,
          colorPalette,
        }),
      ]),
  ])
}

function renderThemeColor(value, options) {
  let {colorPalette, bg} = options,
    blendMode = value._blend || 'multiply',
    baseBg = renderColorValue(value.bg, {colorPalette, bg, blendMode}),
    colorOptions = {colorPalette, bg: baseBg, blendMode},
    button = renderThemeColorButton(value.button, {
      baseBg,
      blendMode,
      colorPalette,
    }),
    selectable = renderThemeColorSelectable(value.selectable, {
      colorPalette,
      baseBg,
      blendMode,
    }),
    shadow = {
      outline: renderColorValue(value.shadow.outline, colorOptions),
      umbra: renderColorValue(value.shadow.umbra, {
        ...colorOptions,
        bg: void 0,
        colorPalette: {...colorPalette, black: '#000000'},
      }),
      penumbra: renderColorValue(value.shadow.penumbra, {
        ...colorOptions,
        bg: void 0,
        colorPalette: {...colorPalette, black: '#000000'},
      }),
      ambient: renderColorValue(value.shadow.ambient, {
        ...colorOptions,
        bg: void 0,
        colorPalette: {...colorPalette, black: '#000000'},
      }),
    }
  return {
    _blend: blendMode,
    _dark: value._dark,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions),
    },
    avatar: renderThemeColorAvatar(value.avatar, {baseBg, colorPalette, blendMode}),
    backdrop: renderColorValue(value.backdrop, colorOptions),
    badge: renderThemeColorBadge(value.badge, {baseBg, colorPalette, blendMode}),
    bg: baseBg,
    border: renderColorValue(value.border, colorOptions),
    button,
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions),
    },
    fg: renderColorValue(value.fg, colorOptions),
    focusRing: renderColorValue(value.focusRing, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    input: renderThemeColorInput(value.input, {baseBg, colorPalette, blendMode}),
    kbd: renderThemeColorKBD(value.kbd, {baseBg, colorPalette, blendMode}),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions),
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions),
    },
    shadow,
    skeleton: {
      from: renderColorValue(value.skeleton.from, colorOptions),
      to: renderColorValue(value.skeleton.to, colorOptions),
    },
    syntax: renderSyntaxColorTheme(value.syntax, {baseBg, colorPalette, blendMode}),
    selectable,
  }
}

function renderThemeColorKBD(value, options) {
  let {baseBg, blendMode, colorPalette} = options,
    rootOptions = {
      bg: baseBg,
      blendMode,
      colorPalette,
    },
    bg = renderColorValue(value.bg, rootOptions),
    colorOptions = {
      bg,
      blendMode,
      colorPalette,
    }
  return {
    bg,
    fg: renderColorValue(value.fg, colorOptions),
    border: renderColorValue(value.border, colorOptions),
  }
}

function renderThemeColorAvatar(value, options) {
  return {
    gray: renderThemeColorAvatarColor(value.gray, options),
    blue: renderThemeColorAvatarColor(value.blue, options),
    purple: renderThemeColorAvatarColor(value.purple, options),
    magenta: renderThemeColorAvatarColor(value.magenta, options),
    red: renderThemeColorAvatarColor(value.red, options),
    orange: renderThemeColorAvatarColor(value.orange, options),
    yellow: renderThemeColorAvatarColor(value.yellow, options),
    green: renderThemeColorAvatarColor(value.green, options),
    cyan: renderThemeColorAvatarColor(value.cyan, options),
  }
}

function renderThemeColorAvatarColor(value, options) {
  let {baseBg, blendMode: rootBlendMode, colorPalette} = options,
    blendMode = value._blend || 'multiply',
    rootOptions = {
      bg: baseBg,
      blendMode: rootBlendMode,
      colorPalette,
    },
    bg = renderColorValue(value.bg, rootOptions),
    colorOptions = {
      bg,
      blendMode,
      colorPalette,
    }
  return {
    _blend: blendMode,
    bg,
    fg: renderColorValue(value.fg, colorOptions),
  }
}

function renderThemeColorBadge(value, options) {
  return {
    default: renderThemeColorBadgeColor(value.default, options),
    primary: renderThemeColorBadgeColor(value.primary, options),
    positive: renderThemeColorBadgeColor(value.positive, options),
    caution: renderThemeColorBadgeColor(value.caution, options),
    critical: renderThemeColorBadgeColor(value.critical, options),
  }
}

function renderThemeColorBadgeColor(value, options) {
  let {baseBg, blendMode: rootBlendMode, colorPalette} = options,
    blendMode = rootBlendMode,
    rootOptions = {
      bg: baseBg,
      blendMode: rootBlendMode,
      colorPalette,
    },
    bg = renderColorValue(value.bg, rootOptions),
    colorOptions = {
      bg,
      blendMode,
      colorPalette,
    }
  return {
    bg,
    dot: renderColorValue(value.dot, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
  }
}

function renderThemeColorButton(value, options) {
  return {
    default: renderThemeColorButtonTones(value.default, options),
    ghost: renderThemeColorButtonTones(value.ghost, options),
    bleed: renderThemeColorButtonTones(value.bleed, options),
  }
}

function renderThemeColorButtonTones(value, options) {
  return {
    default: renderThemeColorButtonStates(value.default, options),
    primary: renderThemeColorButtonStates(value.primary, options),
    positive: renderThemeColorButtonStates(value.positive, options),
    caution: renderThemeColorButtonStates(value.caution, options),
    critical: renderThemeColorButtonStates(value.critical, options),
  }
}

function renderThemeColorButtonStates(value, options) {
  return {
    enabled: renderThemeColorState(value.enabled, options),
    hovered: renderThemeColorState(value.hovered, options),
    pressed: renderThemeColorState(value.pressed, options),
    selected: renderThemeColorState(value.selected, options),
    disabled: renderThemeColorState(value.disabled, options),
  }
}

function renderThemeColorState(value, options) {
  const _a, _b
  let {baseBg, blendMode: rootBlendMode, colorPalette} = options,
    blendMode = value._blend || 'multiply',
    rootOptions = {
      bg: baseBg,
      blendMode: rootBlendMode,
      colorPalette,
    },
    bg = renderColorValue(value.bg, rootOptions),
    colorOptions = {
      bg,
      blendMode,
      colorPalette,
    }
  return {
    _blend: blendMode,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions),
    },
    avatar: renderThemeColorAvatar(value.avatar, {baseBg, colorPalette, blendMode}),
    badge: renderThemeColorBadge(value.badge, {baseBg: bg, colorPalette, blendMode}),
    bg,
    border: renderColorValue(value.border, colorOptions),
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions),
    },
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions),
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions),
    },
    kbd: {
      bg: renderColorValue(value.kbd.bg, colorOptions),
      fg: renderColorValue(value.kbd.fg, colorOptions),
      border: renderColorValue(value.kbd.border, colorOptions),
    },
    skeleton: {
      from: renderColorValue((_a = value.skeleton) == null ? void 0 : _a.from, colorOptions),
      to: renderColorValue((_b = value.skeleton) == null ? void 0 : _b.to, colorOptions),
    },
  }
}

function renderThemeColorInput(value, options) {
  return {
    default: renderInputStatesColorTheme(value.default, options),
    invalid: renderInputStatesColorTheme(value.invalid, options),
  }
}

function renderInputStatesColorTheme(value, options) {
  return {
    enabled: renderInputStateColorTheme(value.enabled, options),
    hovered: renderInputStateColorTheme(value.hovered, options),
    readOnly: renderInputStateColorTheme(value.readOnly, options),
    disabled: renderInputStateColorTheme(value.disabled, options),
  }
}

function renderInputStateColorTheme(value, options) {
  let {baseBg, blendMode: rootBlendMode, colorPalette} = options,
    blendMode = value._blend || 'multiply',
    rootOptions = {colorPalette, bg: baseBg, blendMode: rootBlendMode},
    bg = renderColorValue(value.bg, rootOptions),
    colorOptions = {colorPalette, bg, blendMode}
  return {
    _blend: blendMode,
    bg,
    border: renderColorValue(value.border, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
    },
    placeholder: renderColorValue(value.placeholder, colorOptions),
  }
}

function renderThemeColorSelectable(value, options) {
  return {
    default: renderThemeColorSelectableStates(value.default, options),
    primary: renderThemeColorSelectableStates(value.primary, options),
    positive: renderThemeColorSelectableStates(value.positive, options),
    caution: renderThemeColorSelectableStates(value.caution, options),
    critical: renderThemeColorSelectableStates(value.critical, options),
  }
}

function renderThemeColorSelectableStates(value, options) {
  return {
    enabled: renderThemeColorState(value.enabled, options),
    hovered: renderThemeColorState(value.hovered, options),
    pressed: renderThemeColorState(value.pressed, options),
    selected: renderThemeColorState(value.selected, options),
    disabled: renderThemeColorState(value.disabled, options),
  }
}

function renderSyntaxColorTheme(value, options) {
  let {colorPalette, baseBg, blendMode} = options,
    colorOptions = {colorPalette, bg: baseBg, blendMode}
  return {
    atrule: renderColorValue(value.atrule, colorOptions),
    attrName: renderColorValue(value.attrName, colorOptions),
    attrValue: renderColorValue(value.attrValue, colorOptions),
    attribute: renderColorValue(value.attribute, colorOptions),
    boolean: renderColorValue(value.boolean, colorOptions),
    builtin: renderColorValue(value.builtin, colorOptions),
    cdata: renderColorValue(value.cdata, colorOptions),
    char: renderColorValue(value.char, colorOptions),
    class: renderColorValue(value.class, colorOptions),
    className: renderColorValue(value.className, colorOptions),
    comment: renderColorValue(value.comment, colorOptions),
    constant: renderColorValue(value.constant, colorOptions),
    deleted: renderColorValue(value.deleted, colorOptions),
    doctype: renderColorValue(value.doctype, colorOptions),
    entity: renderColorValue(value.entity, colorOptions),
    function: renderColorValue(value.function, colorOptions),
    hexcode: renderColorValue(value.hexcode, colorOptions),
    id: renderColorValue(value.id, colorOptions),
    important: renderColorValue(value.important, colorOptions),
    inserted: renderColorValue(value.inserted, colorOptions),
    keyword: renderColorValue(value.keyword, colorOptions),
    number: renderColorValue(value.number, colorOptions),
    operator: renderColorValue(value.operator, colorOptions),
    prolog: renderColorValue(value.prolog, colorOptions),
    property: renderColorValue(value.property, colorOptions),
    pseudoClass: renderColorValue(value.pseudoClass, colorOptions),
    pseudoElement: renderColorValue(value.pseudoElement, colorOptions),
    punctuation: renderColorValue(value.punctuation, colorOptions),
    regex: renderColorValue(value.regex, colorOptions),
    selector: renderColorValue(value.selector, colorOptions),
    string: renderColorValue(value.string, colorOptions),
    symbol: renderColorValue(value.symbol, colorOptions),
    tag: renderColorValue(value.tag, colorOptions),
    unit: renderColorValue(value.unit, colorOptions),
    url: renderColorValue(value.url, colorOptions),
    variable: renderColorValue(value.variable, colorOptions),
  }
}

function buildTheme(config) {
  const _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l
  let colorTheme = buildColorTheme(config),
    v2 = {
      _version: 2,
      avatar:
        (_a = config == null ? void 0 : config.avatar) != null ? _a : defaultThemeConfig.avatar,
      button:
        (_b = config == null ? void 0 : config.button) != null ? _b : defaultThemeConfig.button,
      card: (_c = config == null ? void 0 : config.card) != null ? _c : defaultThemeConfig.card,
      // How colors are generated:
      // 1. Merge custom tokens with default tokens
      // 2. Generate tree of color keys (gray/500, black, white, etc.)
      // 3. Apply mixing and render to hex values
      // render(build(mergeWithDefaults()))
      color: renderThemeColorSchemes(colorTheme, config),
      container:
        (_d = config == null ? void 0 : config.container) != null
          ? _d
          : defaultThemeConfig.container,
      font: (_e = config == null ? void 0 : config.font) != null ? _e : defaultThemeFonts,
      input: (_f = config == null ? void 0 : config.input) != null ? _f : defaultThemeConfig.input,
      layer: (_g = config == null ? void 0 : config.layer) != null ? _g : defaultThemeConfig.layer,
      media: (_h = config == null ? void 0 : config.media) != null ? _h : defaultThemeConfig.media,
      radius:
        (_i = config == null ? void 0 : config.radius) != null ? _i : defaultThemeConfig.radius,
      shadow:
        (_j = config == null ? void 0 : config.shadow) != null ? _j : defaultThemeConfig.shadow,
      space: (_k = config == null ? void 0 : config.space) != null ? _k : defaultThemeConfig.space,
      style: (_l = config == null ? void 0 : config.style) != null ? _l : defaultThemeConfig.style,
    }
  return v2_v0(v2)
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/core/_compat.ts
const studioTheme = buildTheme()

// ../../node_modules/.pnpm/@sanity+color@2.2.5/node_modules/@sanity/color/dist/index.js
const black$1 = '#101112',
  white$1 = '#fff',
  gray2 = {
    50: {
      title: 'Gray 50',
      hex: '#f2f3f5',
    },
    100: {
      title: 'Gray 100',
      hex: '#e6e8ec',
    },
    200: {
      title: 'Gray 200',
      hex: '#ced2d9',
    },
    300: {
      title: 'Gray 300',
      hex: '#b6bcc6',
    },
    400: {
      title: 'Gray 400',
      hex: '#9ea6b3',
    },
    500: {
      title: 'Gray 500',
      hex: '#8690a0',
    },
    600: {
      title: 'Gray 600',
      hex: '#6e7683',
    },
    700: {
      title: 'Gray 700',
      hex: '#565d67',
    },
    800: {
      title: 'Gray 800',
      hex: '#3f434a',
    },
    900: {
      title: 'Gray 900',
      hex: '#272a2e',
    },
    950: {
      title: 'Gray 950',
      hex: '#1b1d20',
    },
  },
  blue2 = {
    50: {
      title: 'Blue 50',
      hex: '#e8f1fe',
    },
    100: {
      title: 'Blue 100',
      hex: '#d2e3fe',
    },
    200: {
      title: 'Blue 200',
      hex: '#a6c8fd',
    },
    300: {
      title: 'Blue 300',
      hex: '#7aacfd',
    },
    400: {
      title: 'Blue 400',
      hex: '#4e91fc',
    },
    500: {
      title: 'Blue 500',
      hex: '#2276fc',
    },
    600: {
      title: 'Blue 600',
      hex: '#1e61cd',
    },
    700: {
      title: 'Blue 700',
      hex: '#1a4d9e',
    },
    800: {
      title: 'Blue 800',
      hex: '#17396f',
    },
    900: {
      title: 'Blue 900',
      hex: '#132540',
    },
    950: {
      title: 'Blue 950',
      hex: '#111b29',
    },
  },
  purple2 = {
    50: {
      title: 'Purple 50',
      hex: '#f8e9fe',
    },
    100: {
      title: 'Purple 100',
      hex: '#f2d3fe',
    },
    200: {
      title: 'Purple 200',
      hex: '#e6a7fd',
    },
    300: {
      title: 'Purple 300',
      hex: '#d97bfd',
    },
    400: {
      title: 'Purple 400',
      hex: '#cd4efc',
    },
    500: {
      title: 'Purple 500',
      hex: '#c123fc',
    },
    600: {
      title: 'Purple 600',
      hex: '#9d1fcd',
    },
    700: {
      title: 'Purple 700',
      hex: '#7a1b9e',
    },
    800: {
      title: 'Purple 800',
      hex: '#56186f',
    },
    900: {
      title: 'Purple 900',
      hex: '#331440',
    },
    950: {
      title: 'Purple 950',
      hex: '#211229',
    },
  },
  magenta2 = {
    50: {
      title: 'Magenta 50',
      hex: '#fcebf5',
    },
    100: {
      title: 'Magenta 100',
      hex: '#f9d7eb',
    },
    200: {
      title: 'Magenta 200',
      hex: '#f4afd8',
    },
    300: {
      title: 'Magenta 300',
      hex: '#ef87c4',
    },
    400: {
      title: 'Magenta 400',
      hex: '#ea5fb1',
    },
    500: {
      title: 'Magenta 500',
      hex: '#e5389e',
    },
    600: {
      title: 'Magenta 600',
      hex: '#ba3082',
    },
    700: {
      title: 'Magenta 700',
      hex: '#8f2866',
    },
    800: {
      title: 'Magenta 800',
      hex: '#65204a',
    },
    900: {
      title: 'Magenta 900',
      hex: '#3a182d',
    },
    950: {
      title: 'Magenta 950',
      hex: '#25141f',
    },
  },
  red2 = {
    50: {
      title: 'Red 50',
      hex: '#fdebea',
    },
    100: {
      title: 'Red 100',
      hex: '#fcd8d5',
    },
    200: {
      title: 'Red 200',
      hex: '#f9b1ab',
    },
    300: {
      title: 'Red 300',
      hex: '#f68b82',
    },
    400: {
      title: 'Red 400',
      hex: '#f36458',
    },
    500: {
      title: 'Red 500',
      hex: '#f03e2f',
    },
    600: {
      title: 'Red 600',
      hex: '#c33529',
    },
    700: {
      title: 'Red 700',
      hex: '#962c23',
    },
    800: {
      title: 'Red 800',
      hex: '#69231d',
    },
    900: {
      title: 'Red 900',
      hex: '#3c1a17',
    },
    950: {
      title: 'Red 950',
      hex: '#261514',
    },
  },
  orange2 = {
    50: {
      title: 'Orange 50',
      hex: '#fef0e6',
    },
    100: {
      title: 'Orange 100',
      hex: '#fee2ce',
    },
    200: {
      title: 'Orange 200',
      hex: '#fdc59d',
    },
    300: {
      title: 'Orange 300',
      hex: '#fca86d',
    },
    400: {
      title: 'Orange 400',
      hex: '#fb8b3c',
    },
    500: {
      title: 'Orange 500',
      hex: '#e57322',
    },
    600: {
      title: 'Orange 600',
      hex: '#ba5f1f',
    },
    700: {
      title: 'Orange 700',
      hex: '#904b1b',
    },
    800: {
      title: 'Orange 800',
      hex: '#653818',
    },
    900: {
      title: 'Orange 900',
      hex: '#3a2415',
    },
    950: {
      title: 'Orange 950',
      hex: '#251a13',
    },
  },
  yellow2 = {
    50: {
      title: 'Yellow 50',
      hex: '#fef7da',
    },
    100: {
      title: 'Yellow 100',
      hex: '#fdefb6',
    },
    200: {
      title: 'Yellow 200',
      hex: '#fcdf6d',
    },
    300: {
      title: 'Yellow 300',
      hex: '#fbd024',
    },
    400: {
      title: 'Yellow 400',
      hex: '#d9b421',
    },
    500: {
      title: 'Yellow 500',
      hex: '#b7991e',
    },
    600: {
      title: 'Yellow 600',
      hex: '#967e1c',
    },
    700: {
      title: 'Yellow 700',
      hex: '#746219',
    },
    800: {
      title: 'Yellow 800',
      hex: '#534717',
    },
    900: {
      title: 'Yellow 900',
      hex: '#312c14',
    },
    950: {
      title: 'Yellow 950',
      hex: '#201e13',
    },
  },
  green2 = {
    50: {
      title: 'Green 50',
      hex: '#e7f9ed',
    },
    100: {
      title: 'Green 100',
      hex: '#d0f4dc',
    },
    200: {
      title: 'Green 200',
      hex: '#a1eaba',
    },
    300: {
      title: 'Green 300',
      hex: '#72e097',
    },
    400: {
      title: 'Green 400',
      hex: '#43d675',
    },
    500: {
      title: 'Green 500',
      hex: '#3ab564',
    },
    600: {
      title: 'Green 600',
      hex: '#329454',
    },
    700: {
      title: 'Green 700',
      hex: '#297343',
    },
    800: {
      title: 'Green 800',
      hex: '#215233',
    },
    900: {
      title: 'Green 900',
      hex: '#183122',
    },
    950: {
      title: 'Green 950',
      hex: '#14211a',
    },
  },
  cyan2 = {
    50: {
      title: 'Cyan 50',
      hex: '#e3fafd',
    },
    100: {
      title: 'Cyan 100',
      hex: '#c7f5fc',
    },
    200: {
      title: 'Cyan 200',
      hex: '#90ecf9',
    },
    300: {
      title: 'Cyan 300',
      hex: '#59e3f6',
    },
    400: {
      title: 'Cyan 400',
      hex: '#22daf4',
    },
    500: {
      title: 'Cyan 500',
      hex: '#1fb8ce',
    },
    600: {
      title: 'Cyan 600',
      hex: '#1c97a8',
    },
    700: {
      title: 'Cyan 700',
      hex: '#197583',
    },
    800: {
      title: 'Cyan 800',
      hex: '#16545d',
    },
    900: {
      title: 'Cyan 900',
      hex: '#133237',
    },
    950: {
      title: 'Cyan 950',
      hex: '#112124',
    },
  },
  hues2 = {
    gray: gray2,
    blue: blue2,
    purple: purple2,
    magenta: magenta2,
    red: red2,
    orange: orange2,
    yellow: yellow2,
    green: green2,
    cyan: cyan2,
  }
const COLOR_TINTS2 = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950'],
  black2 = {
    title: 'Black',
    hex: black$1,
  },
  white2 = {
    title: 'White',
    hex: white$1,
  }

// utils/colors.ts
const lightest = white2.hex.toLowerCase(),
  darkest = black2.hex.toLowerCase(),
  NEUTRAL_TONES = ['default', 'transparent']
const {
  blue: blue3,
  cyan: cyan3,
  gray: gray3,
  green: green3,
  magenta: magenta3,
  orange: orange3,
  purple: purple3,
  red: red3,
  yellow: yellow3,
} = hues2

// utils/applyHues.ts
const defaultHues = {
  default: {
    lightest,
    darkest,
    mid: '#8690a0',
    midPoint: 500,
  },
  primary: {
    lightest,
    darkest,
    mid: '#2276fc',
    midPoint: 500,
  },
  transparent: {
    lightest,
    darkest,
    mid: '#8690a0',
    midPoint: 500,
  },
  positive: {
    lightest,
    darkest,
    mid: '#43d675',
    midPoint: 400,
  },
  caution: {
    lightest,
    darkest,
    mid: '#fbd024',
    midPoint: 300,
  },
  critical: {
    lightest,
    darkest,
    mid: '#f03e2f',
    midPoint: 500,
  },
}

function applyHues(_hues, defaults = defaultHues) {
  const _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l
  let hues4 = JSON.parse(JSON.stringify(_hues)),
    defaultMid =
      ((_b = (_a = hues4.default) == null ? void 0 : _a.mid) == null ? void 0 : _b.toLowerCase()) ||
      defaults.default.mid,
    primaryMid =
      ((_d = (_c = hues4.primary) == null ? void 0 : _c.mid) == null ? void 0 : _d.toLowerCase()) ||
      defaults.primary.mid,
    transparentMid =
      ((_f = (_e = hues4.transparent) == null ? void 0 : _e.mid) == null
        ? void 0
        : _f.toLowerCase()) || defaults.transparent.mid,
    positiveMid =
      ((_h = (_g = hues4.positive) == null ? void 0 : _g.mid) == null
        ? void 0
        : _h.toLowerCase()) || defaults.positive.mid,
    cautionMid =
      ((_j = (_i = hues4.caution) == null ? void 0 : _i.mid) == null ? void 0 : _j.toLowerCase()) ||
      defaults.caution.mid,
    criticalMid =
      ((_l = (_k = hues4.critical) == null ? void 0 : _k.mid) == null
        ? void 0
        : _l.toLowerCase()) || defaults.critical.mid
  return {
    default: {
      ...defaults.default,
      midPoint: defaultMid === defaults.default.mid ? defaults.default.midPoint : 500,
      ...hues4.default,
      mid: defaultMid,
    },
    primary: {
      ...defaults.primary,
      midPoint: primaryMid === defaults.primary.mid ? defaults.primary.midPoint : 500,
      ...hues4.primary,
      mid: primaryMid,
    },
    transparent: {
      ...defaults.transparent,
      midPoint: transparentMid === defaults.transparent.mid ? defaults.transparent.midPoint : 500,
      ...hues4.transparent,
      mid: transparentMid,
    },
    positive: {
      ...defaults.positive,
      midPoint: positiveMid === defaults.positive.mid ? defaults.positive.midPoint : 500,
      ...hues4.positive,
      mid: positiveMid,
    },
    caution: {
      ...defaults.caution,
      midPoint: cautionMid === defaults.caution.mid ? defaults.caution.midPoint : 500,
      ...hues4.caution,
      mid: cautionMid,
    },
    critical: {
      ...defaults.critical,
      midPoint: criticalMid === defaults.critical.mid ? defaults.critical.midPoint : 500,
      ...hues4.critical,
      mid: criticalMid,
    },
  }
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return (
    (_extends = Object.assign
      ? Object.assign.bind()
      : function (target) {
          for (const i = 1; i < arguments.length; i++) {
            const source = arguments[i]
            for (const key in source)
              Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
          }
          return target
        }),
    _extends.apply(this, arguments)
  )
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  return self
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  return (
    (_setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (o2, p2) {
          return ((o2.__proto__ = p2), o2)
        }),
    _setPrototypeOf(o, p)
  )
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  ;((subClass.prototype = Object.create(superClass.prototype)),
    (subClass.prototype.constructor = subClass),
    _setPrototypeOf(subClass, superClass))
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  return (
    (_getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2)
        }),
    _getPrototypeOf(o)
  )
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf('[native code]') !== -1
  } catch (e) {
    return typeof fn == 'function'
  }
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    const t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}))
  } catch (t2) {}
  return (_isNativeReflectConstruct = function () {
    return !!t
  })()
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments)
  const o = [null]
  o.push.apply(o, e)
  const p = new (t.bind.apply(t, o))()
  return (r && _setPrototypeOf(p, r.prototype), p)
}

// ../../node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  const _cache = typeof Map == 'function' ? /* @__PURE__ */ new Map() : void 0
  return (
    (_wrapNativeSuper = function (Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2
      if (typeof Class2 != 'function')
        throw new TypeError('Super expression must either be null or a function')
      if (typeof _cache < 'u') {
        if (_cache.has(Class2)) return _cache.get(Class2)
        _cache.set(Class2, Wrapper)
      }

      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor)
      }

      return (
        (Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        _setPrototypeOf(Wrapper, Class2)
      )
    }),
    _wrapNativeSuper(Class)
  )
}

// ../../node_modules/.pnpm/polished@4.3.1/node_modules/polished/dist/polished.esm.js
const ERRORS = {
  1: 'Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n',
  2: 'Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n',
  3: 'Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n',
  4: "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
  5: "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
  6: 'Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n',
  7: 'Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n',
  8: 'Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n',
  9: 'Please provide a number of steps to the modularScale helper.\n\n',
  10: 'Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n',
  11: 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n',
  12: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n',
  13: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n',
  14: 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  15: 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  16: 'You must provide a template to this method.\n\n',
  17: 'You passed an unsupported selector state to this method.\n\n',
  18: 'minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n',
  19: 'fromSize and toSize must be provided as stringified numbers with the same units.\n\n',
  20: 'expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n',
  21: 'expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n',
  22: 'expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n',
  23: 'fontFace expects a name of a font-family.\n\n',
  24: 'fontFace expects either the path to the font file(s) or a name of a local copy.\n\n',
  25: 'fontFace expects localFonts to be an array.\n\n',
  26: 'fontFace expects fileFormats to be an array.\n\n',
  27: 'radialGradient requries at least 2 color-stops to properly render.\n\n',
  28: 'Please supply a filename to retinaImage() as the first argument.\n\n',
  29: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  30: 'Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n',
  31: 'The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n',
  32: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
  33: 'The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n',
  34: 'borderRadius expects a radius value as a string or number as the second argument.\n\n',
  35: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  36: 'Property must be a string value.\n\n',
  37: 'Syntax Error at %s.\n\n',
  38: 'Formula contains a function that needs parentheses at %s.\n\n',
  39: 'Formula is missing closing parenthesis at %s.\n\n',
  40: 'Formula has too many closing parentheses at %s.\n\n',
  41: 'All values in a formula must have the same unit or be unitless.\n\n',
  42: 'Please provide a number of steps to the modularScale helper.\n\n',
  43: 'Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n',
  44: 'Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n',
  45: 'Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n',
  46: 'Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n',
  47: 'minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n',
  48: 'fromSize and toSize must be provided as stringified numbers with the same units.\n\n',
  49: 'Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n',
  50: 'Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n',
  51: 'Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n',
  52: 'fontFace expects either the path to the font file(s) or a name of a local copy.\n\n',
  53: 'fontFace expects localFonts to be an array.\n\n',
  54: 'fontFace expects fileFormats to be an array.\n\n',
  55: 'fontFace expects a name of a font-family.\n\n',
  56: 'linearGradient requries at least 2 color-stops to properly render.\n\n',
  57: 'radialGradient requries at least 2 color-stops to properly render.\n\n',
  58: 'Please supply a filename to retinaImage() as the first argument.\n\n',
  59: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  60: 'Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n',
  61: 'Property must be a string value.\n\n',
  62: 'borderRadius expects a radius value as a string or number as the second argument.\n\n',
  63: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  64: 'The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n',
  65: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
  66: 'The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n',
  67: 'You must provide a template to this method.\n\n',
  68: 'You passed an unsupported selector state to this method.\n\n',
  69: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n',
  70: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n',
  71: 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n',
  72: 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n',
  73: 'Please provide a valid CSS variable.\n\n',
  74: 'CSS variable not found and no default was provided.\n\n',
  75: 'important requires a valid style object, got a %s instead.\n\n',
  76: 'fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n',
  77: 'remToPx expects a value in "rem" but you provided it in "%s".\n\n',
  78: 'base must be set in "px" or "%" but you set it in "%s".\n',
}

function format() {
  for (const _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key]
  const a = args[0],
    b = [],
    c
  for (c = 1; c < args.length; c += 1) b.push(args[c])
  return (
    b.forEach(function (d) {
      a = a.replace(/%[a-z]/, d)
    }),
    a
  )
}

const PolishedError = /* @__PURE__ */ (function (_Error) {
  _inheritsLoose(PolishedError2, _Error)

  function PolishedError2(code) {
    for (
      const _this, _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
      _key2 < _len2;
      _key2++
    )
      args[_key2 - 1] = arguments[_key2]
    return (
      (_this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this),
      _assertThisInitialized(_this)
    )
  }

  return PolishedError2
})(/* @__PURE__ */ _wrapNativeSuper(Error))

function endsWith(string, suffix) {
  return string.substr(-suffix.length) === suffix
}

const cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/

function stripUnit(value) {
  if (typeof value != 'string') return value
  const matchedValue = value.match(cssRegex$1)
  return matchedValue ? parseFloat(value) : value
}

const pxtoFactory = function (to) {
    return function (pxval, base) {
      base === void 0 && (base = '16px')
      const newPxval = pxval,
        newBase = base
      if (typeof pxval == 'string') {
        if (!endsWith(pxval, 'px')) throw new PolishedError(69, to, pxval)
        newPxval = stripUnit(pxval)
      }
      if (typeof base == 'string') {
        if (!endsWith(base, 'px')) throw new PolishedError(70, to, base)
        newBase = stripUnit(base)
      }
      if (typeof newPxval == 'string') throw new PolishedError(71, pxval, to)
      if (typeof newBase == 'string') throw new PolishedError(72, base, to)
      return '' + newPxval / newBase + to
    }
  },
  pixelsto = pxtoFactory,
  em = pixelsto('em')
const rem = pixelsto('rem')

function colorToInt(color2) {
  return Math.round(color2 * 255)
}

function convertToInt(red4, green4, blue4) {
  return colorToInt(red4) + ',' + colorToInt(green4) + ',' + colorToInt(blue4)
}

function hslToRgb2(hue, saturation, lightness, convert) {
  if ((convert === void 0 && (convert = convertToInt), saturation === 0))
    return convert(lightness, lightness, lightness)
  const huePrime = (((hue % 360) + 360) % 360) / 60,
    chroma = (1 - Math.abs(2 * lightness - 1)) * saturation,
    secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1)),
    red4 = 0,
    green4 = 0,
    blue4 = 0
  huePrime >= 0 && huePrime < 1
    ? ((red4 = chroma), (green4 = secondComponent))
    : huePrime >= 1 && huePrime < 2
      ? ((red4 = secondComponent), (green4 = chroma))
      : huePrime >= 2 && huePrime < 3
        ? ((green4 = chroma), (blue4 = secondComponent))
        : huePrime >= 3 && huePrime < 4
          ? ((green4 = secondComponent), (blue4 = chroma))
          : huePrime >= 4 && huePrime < 5
            ? ((red4 = secondComponent), (blue4 = chroma))
            : huePrime >= 5 && huePrime < 6 && ((red4 = chroma), (blue4 = secondComponent))
  const lightnessModification = lightness - chroma / 2,
    finalRed = red4 + lightnessModification,
    finalGreen = green4 + lightnessModification,
    finalBlue = blue4 + lightnessModification
  return convert(finalRed, finalGreen, finalBlue)
}

const namedColorMap = {
  aliceblue: 'f0f8ff',
  antiquewhite: 'faebd7',
  aqua: '00ffff',
  aquamarine: '7fffd4',
  azure: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '000',
  blanchedalmond: 'ffebcd',
  blue: '0000ff',
  blueviolet: '8a2be2',
  brown: 'a52a2a',
  burlywood: 'deb887',
  cadetblue: '5f9ea0',
  chartreuse: '7fff00',
  chocolate: 'd2691e',
  coral: 'ff7f50',
  cornflowerblue: '6495ed',
  cornsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: '00ffff',
  darkblue: '00008b',
  darkcyan: '008b8b',
  darkgoldenrod: 'b8860b',
  darkgray: 'a9a9a9',
  darkgreen: '006400',
  darkgrey: 'a9a9a9',
  darkkhaki: 'bdb76b',
  darkmagenta: '8b008b',
  darkolivegreen: '556b2f',
  darkorange: 'ff8c00',
  darkorchid: '9932cc',
  darkred: '8b0000',
  darksalmon: 'e9967a',
  darkseagreen: '8fbc8f',
  darkslateblue: '483d8b',
  darkslategray: '2f4f4f',
  darkslategrey: '2f4f4f',
  darkturquoise: '00ced1',
  darkviolet: '9400d3',
  deeppink: 'ff1493',
  deepskyblue: '00bfff',
  dimgray: '696969',
  dimgrey: '696969',
  dodgerblue: '1e90ff',
  firebrick: 'b22222',
  floralwhite: 'fffaf0',
  forestgreen: '228b22',
  fuchsia: 'ff00ff',
  gainsboro: 'dcdcdc',
  ghostwhite: 'f8f8ff',
  gold: 'ffd700',
  goldenrod: 'daa520',
  gray: '808080',
  green: '008000',
  greenyellow: 'adff2f',
  grey: '808080',
  honeydew: 'f0fff0',
  hotpink: 'ff69b4',
  indianred: 'cd5c5c',
  indigo: '4b0082',
  ivory: 'fffff0',
  khaki: 'f0e68c',
  lavender: 'e6e6fa',
  lavenderblush: 'fff0f5',
  lawngreen: '7cfc00',
  lemonchiffon: 'fffacd',
  lightblue: 'add8e6',
  lightcoral: 'f08080',
  lightcyan: 'e0ffff',
  lightgoldenrodyellow: 'fafad2',
  lightgray: 'd3d3d3',
  lightgreen: '90ee90',
  lightgrey: 'd3d3d3',
  lightpink: 'ffb6c1',
  lightsalmon: 'ffa07a',
  lightseagreen: '20b2aa',
  lightskyblue: '87cefa',
  lightslategray: '789',
  lightslategrey: '789',
  lightsteelblue: 'b0c4de',
  lightyellow: 'ffffe0',
  lime: '0f0',
  limegreen: '32cd32',
  linen: 'faf0e6',
  magenta: 'f0f',
  maroon: '800000',
  mediumaquamarine: '66cdaa',
  mediumblue: '0000cd',
  mediumorchid: 'ba55d3',
  mediumpurple: '9370db',
  mediumseagreen: '3cb371',
  mediumslateblue: '7b68ee',
  mediumspringgreen: '00fa9a',
  mediumturquoise: '48d1cc',
  mediumvioletred: 'c71585',
  midnightblue: '191970',
  mintcream: 'f5fffa',
  mistyrose: 'ffe4e1',
  moccasin: 'ffe4b5',
  navajowhite: 'ffdead',
  navy: '000080',
  oldlace: 'fdf5e6',
  olive: '808000',
  olivedrab: '6b8e23',
  orange: 'ffa500',
  orangered: 'ff4500',
  orchid: 'da70d6',
  palegoldenrod: 'eee8aa',
  palegreen: '98fb98',
  paleturquoise: 'afeeee',
  palevioletred: 'db7093',
  papayawhip: 'ffefd5',
  peachpuff: 'ffdab9',
  peru: 'cd853f',
  pink: 'ffc0cb',
  plum: 'dda0dd',
  powderblue: 'b0e0e6',
  purple: '800080',
  rebeccapurple: '639',
  red: 'f00',
  rosybrown: 'bc8f8f',
  royalblue: '4169e1',
  saddlebrown: '8b4513',
  salmon: 'fa8072',
  sandybrown: 'f4a460',
  seagreen: '2e8b57',
  seashell: 'fff5ee',
  sienna: 'a0522d',
  silver: 'c0c0c0',
  skyblue: '87ceeb',
  slateblue: '6a5acd',
  slategray: '708090',
  slategrey: '708090',
  snow: 'fffafa',
  springgreen: '00ff7f',
  steelblue: '4682b4',
  tan: 'd2b48c',
  teal: '008080',
  thistle: 'd8bfd8',
  tomato: 'ff6347',
  turquoise: '40e0d0',
  violet: 'ee82ee',
  wheat: 'f5deb3',
  white: 'fff',
  whitesmoke: 'f5f5f5',
  yellow: 'ff0',
  yellowgreen: '9acd32',
}

function nameToHex(color2) {
  if (typeof color2 != 'string') return color2
  const normalizedColorName = color2.toLowerCase()
  return namedColorMap[normalizedColorName] ? '#' + namedColorMap[normalizedColorName] : color2
}

const hexRegex = /^#[a-fA-F0-9]{6}$/,
  hexRgbaRegex = /^#[a-fA-F0-9]{8}$/,
  reducedHexRegex = /^#[a-fA-F0-9]{3}$/,
  reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/,
  rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i,
  rgbaRegex =
    /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i,
  hslRegex =
    /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i,
  hslaRegex =
    /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i

function parseToRgb(color2) {
  if (typeof color2 != 'string') throw new PolishedError(3)
  const normalizedColor = nameToHex(color2)
  if (normalizedColor.match(hexRegex))
    return {
      red: parseInt('' + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt('' + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt('' + normalizedColor[5] + normalizedColor[6], 16),
    }
  if (normalizedColor.match(hexRgbaRegex)) {
    const alpha = parseFloat(
      (parseInt('' + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2),
    )
    return {
      red: parseInt('' + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt('' + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt('' + normalizedColor[5] + normalizedColor[6], 16),
      alpha,
    }
  }
  if (normalizedColor.match(reducedHexRegex))
    return {
      red: parseInt('' + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt('' + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt('' + normalizedColor[3] + normalizedColor[3], 16),
    }
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    const _alpha = parseFloat(
      (parseInt('' + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2),
    )
    return {
      red: parseInt('' + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt('' + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt('' + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha,
    }
  }
  const rgbMatched = rgbRegex.exec(normalizedColor)
  if (rgbMatched)
    return {
      red: parseInt('' + rgbMatched[1], 10),
      green: parseInt('' + rgbMatched[2], 10),
      blue: parseInt('' + rgbMatched[3], 10),
    }
  const rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50))
  if (rgbaMatched)
    return {
      red: parseInt('' + rgbaMatched[1], 10),
      green: parseInt('' + rgbaMatched[2], 10),
      blue: parseInt('' + rgbaMatched[3], 10),
      alpha:
        parseFloat('' + rgbaMatched[4]) > 1
          ? parseFloat('' + rgbaMatched[4]) / 100
          : parseFloat('' + rgbaMatched[4]),
    }
  const hslMatched = hslRegex.exec(normalizedColor)
  if (hslMatched) {
    const hue = parseInt('' + hslMatched[1], 10),
      saturation = parseInt('' + hslMatched[2], 10) / 100,
      lightness = parseInt('' + hslMatched[3], 10) / 100,
      rgbColorString = 'rgb(' + hslToRgb2(hue, saturation, lightness) + ')',
      hslRgbMatched = rgbRegex.exec(rgbColorString)
    if (!hslRgbMatched) throw new PolishedError(4, normalizedColor, rgbColorString)
    return {
      red: parseInt('' + hslRgbMatched[1], 10),
      green: parseInt('' + hslRgbMatched[2], 10),
      blue: parseInt('' + hslRgbMatched[3], 10),
    }
  }
  const hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50))
  if (hslaMatched) {
    const _hue = parseInt('' + hslaMatched[1], 10),
      _saturation = parseInt('' + hslaMatched[2], 10) / 100,
      _lightness = parseInt('' + hslaMatched[3], 10) / 100,
      _rgbColorString = 'rgb(' + hslToRgb2(_hue, _saturation, _lightness) + ')',
      _hslRgbMatched = rgbRegex.exec(_rgbColorString)
    if (!_hslRgbMatched) throw new PolishedError(4, normalizedColor, _rgbColorString)
    return {
      red: parseInt('' + _hslRgbMatched[1], 10),
      green: parseInt('' + _hslRgbMatched[2], 10),
      blue: parseInt('' + _hslRgbMatched[3], 10),
      alpha:
        parseFloat('' + hslaMatched[4]) > 1
          ? parseFloat('' + hslaMatched[4]) / 100
          : parseFloat('' + hslaMatched[4]),
    }
  }
  throw new PolishedError(5)
}

function rgbToHsl(color2) {
  const red4 = color2.red / 255,
    green4 = color2.green / 255,
    blue4 = color2.blue / 255,
    max = Math.max(red4, green4, blue4),
    min = Math.min(red4, green4, blue4),
    lightness = (max + min) / 2
  if (max === min)
    return color2.alpha !== void 0
      ? {
          hue: 0,
          saturation: 0,
          lightness,
          alpha: color2.alpha,
        }
      : {
          hue: 0,
          saturation: 0,
          lightness,
        }
  const hue,
    delta = max - min,
    saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min)
  switch (max) {
    case red4:
      hue = (green4 - blue4) / delta + (green4 < blue4 ? 6 : 0)
      break
    case green4:
      hue = (blue4 - red4) / delta + 2
      break
    default:
      hue = (red4 - green4) / delta + 4
      break
  }
  return (
    (hue *= 60),
    color2.alpha !== void 0
      ? {
          hue,
          saturation,
          lightness,
          alpha: color2.alpha,
        }
      : {
          hue,
          saturation,
          lightness,
        }
  )
}

function parseToHsl(color2) {
  return rgbToHsl(parseToRgb(color2))
}

const reduceHexValue = function (value) {
    return value.length === 7 &&
      value[1] === value[2] &&
      value[3] === value[4] &&
      value[5] === value[6]
      ? '#' + value[1] + value[3] + value[5]
      : value
  },
  reduceHexValue$1 = reduceHexValue

function numberToHex(value) {
  const hex = value.toString(16)
  return hex.length === 1 ? '0' + hex : hex
}

function colorToHex(color2) {
  return numberToHex(Math.round(color2 * 255))
}

function convertToHex(red4, green4, blue4) {
  return reduceHexValue$1('#' + colorToHex(red4) + colorToHex(green4) + colorToHex(blue4))
}

function hslToHex(hue, saturation, lightness) {
  return hslToRgb2(hue, saturation, lightness, convertToHex)
}

function hsl(value, saturation, lightness) {
  if (typeof value == 'number' && typeof saturation == 'number' && typeof lightness == 'number')
    return hslToHex(value, saturation, lightness)
  if (typeof value == 'object' && saturation === void 0 && lightness === void 0)
    return hslToHex(value.hue, value.saturation, value.lightness)
  throw new PolishedError(1)
}

function hsla(value, saturation, lightness, alpha) {
  if (
    typeof value == 'number' &&
    typeof saturation == 'number' &&
    typeof lightness == 'number' &&
    typeof alpha == 'number'
  )
    return alpha >= 1
      ? hslToHex(value, saturation, lightness)
      : 'rgba(' + hslToRgb2(value, saturation, lightness) + ',' + alpha + ')'
  if (typeof value == 'object' && saturation === void 0 && lightness === void 0 && alpha === void 0)
    return value.alpha >= 1
      ? hslToHex(value.hue, value.saturation, value.lightness)
      : 'rgba(' + hslToRgb2(value.hue, value.saturation, value.lightness) + ',' + value.alpha + ')'
  throw new PolishedError(2)
}

function rgb(value, green4, blue4) {
  if (typeof value == 'number' && typeof green4 == 'number' && typeof blue4 == 'number')
    return reduceHexValue$1('#' + numberToHex(value) + numberToHex(green4) + numberToHex(blue4))
  if (typeof value == 'object' && green4 === void 0 && blue4 === void 0)
    return reduceHexValue$1(
      '#' + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue),
    )
  throw new PolishedError(6)
}

function rgba2(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue == 'string' && typeof secondValue == 'number') {
    const rgbValue = parseToRgb(firstValue)
    return (
      'rgba(' + rgbValue.red + ',' + rgbValue.green + ',' + rgbValue.blue + ',' + secondValue + ')'
    )
  } else {
    if (
      typeof firstValue == 'number' &&
      typeof secondValue == 'number' &&
      typeof thirdValue == 'number' &&
      typeof fourthValue == 'number'
    )
      return fourthValue >= 1
        ? rgb(firstValue, secondValue, thirdValue)
        : 'rgba(' + firstValue + ',' + secondValue + ',' + thirdValue + ',' + fourthValue + ')'
    if (
      typeof firstValue == 'object' &&
      secondValue === void 0 &&
      thirdValue === void 0 &&
      fourthValue === void 0
    )
      return firstValue.alpha >= 1
        ? rgb(firstValue.red, firstValue.green, firstValue.blue)
        : 'rgba(' +
            firstValue.red +
            ',' +
            firstValue.green +
            ',' +
            firstValue.blue +
            ',' +
            firstValue.alpha +
            ')'
  }
  throw new PolishedError(7)
}

const isRgb = function (color2) {
    return (
      typeof color2.red == 'number' &&
      typeof color2.green == 'number' &&
      typeof color2.blue == 'number' &&
      (typeof color2.alpha != 'number' || typeof color2.alpha > 'u')
    )
  },
  isRgba = function (color2) {
    return (
      typeof color2.red == 'number' &&
      typeof color2.green == 'number' &&
      typeof color2.blue == 'number' &&
      typeof color2.alpha == 'number'
    )
  },
  isHsl = function (color2) {
    return (
      typeof color2.hue == 'number' &&
      typeof color2.saturation == 'number' &&
      typeof color2.lightness == 'number' &&
      (typeof color2.alpha != 'number' || typeof color2.alpha > 'u')
    )
  },
  isHsla = function (color2) {
    return (
      typeof color2.hue == 'number' &&
      typeof color2.saturation == 'number' &&
      typeof color2.lightness == 'number' &&
      typeof color2.alpha == 'number'
    )
  }

function toColorString(color2) {
  if (typeof color2 != 'object') throw new PolishedError(8)
  if (isRgba(color2)) return rgba2(color2)
  if (isRgb(color2)) return rgb(color2)
  if (isHsla(color2)) return hsla(color2)
  if (isHsl(color2)) return hsl(color2)
  throw new PolishedError(8)
}

function curried(f, length, acc) {
  return function () {
    const combined = acc.concat(Array.prototype.slice.call(arguments))
    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined)
  }
}

function curry(f) {
  return curried(f, f.length, [])
}

function adjustHue(degree, color2) {
  if (color2 === 'transparent') return color2
  const hslColor = parseToHsl(color2)
  return toColorString(
    _extends({}, hslColor, {
      hue: hslColor.hue + parseFloat(degree),
    }),
  )
}

const curriedAdjustHue = curry(adjustHue)

function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value))
}

function darken(amount, color2) {
  if (color2 === 'transparent') return color2
  const hslColor = parseToHsl(color2)
  return toColorString(
    _extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - parseFloat(amount)),
    }),
  )
}

const curriedDarken = curry(darken)

function desaturate(amount, color2) {
  if (color2 === 'transparent') return color2
  const hslColor = parseToHsl(color2)
  return toColorString(
    _extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation - parseFloat(amount)),
    }),
  )
}

const curriedDesaturate = curry(desaturate)

function lighten(amount, color2) {
  if (color2 === 'transparent') return color2
  const hslColor = parseToHsl(color2)
  return toColorString(
    _extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness + parseFloat(amount)),
    }),
  )
}

const curriedLighten = curry(lighten)

function mix2(weight, color2, otherColor) {
  if (color2 === 'transparent') return otherColor
  if (otherColor === 'transparent') return color2
  if (weight === 0) return otherColor
  const parsedColor1 = parseToRgb(color2),
    color1 = _extends({}, parsedColor1, {
      alpha: typeof parsedColor1.alpha == 'number' ? parsedColor1.alpha : 1,
    }),
    parsedColor2 = parseToRgb(otherColor),
    color22 = _extends({}, parsedColor2, {
      alpha: typeof parsedColor2.alpha == 'number' ? parsedColor2.alpha : 1,
    }),
    alphaDelta = color1.alpha - color22.alpha,
    x = parseFloat(weight) * 2 - 1,
    y = x * alphaDelta === -1 ? x : x + alphaDelta,
    z = 1 + x * alphaDelta,
    weight1 = (y / z + 1) / 2,
    weight2 = 1 - weight1,
    mixedColor = {
      red: Math.floor(color1.red * weight1 + color22.red * weight2),
      green: Math.floor(color1.green * weight1 + color22.green * weight2),
      blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
      alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight)),
    }
  return rgba2(mixedColor)
}

const curriedMix = curry(mix2),
  mix$1 = curriedMix

function opacify(amount, color2) {
  if (color2 === 'transparent') return color2
  const parsedColor = parseToRgb(color2),
    alpha = typeof parsedColor.alpha == 'number' ? parsedColor.alpha : 1,
    colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100),
    })
  return rgba2(colorWithAlpha)
}

const curriedOpacify = curry(opacify)

function saturate(amount, color2) {
  if (color2 === 'transparent') return color2
  const hslColor = parseToHsl(color2)
  return toColorString(
    _extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation + parseFloat(amount)),
    }),
  )
}

const curriedSaturate = curry(saturate)

function setHue(hue, color2) {
  return color2 === 'transparent'
    ? color2
    : toColorString(
        _extends({}, parseToHsl(color2), {
          hue: parseFloat(hue),
        }),
      )
}

const curriedSetHue = curry(setHue)

function setLightness(lightness, color2) {
  return color2 === 'transparent'
    ? color2
    : toColorString(
        _extends({}, parseToHsl(color2), {
          lightness: parseFloat(lightness),
        }),
      )
}

const curriedSetLightness = curry(setLightness)

function setSaturation(saturation, color2) {
  return color2 === 'transparent'
    ? color2
    : toColorString(
        _extends({}, parseToHsl(color2), {
          saturation: parseFloat(saturation),
        }),
      )
}

const curriedSetSaturation = curry(setSaturation)

function shade(percentage, color2) {
  return color2 === 'transparent' ? color2 : mix$1(parseFloat(percentage), 'rgb(0, 0, 0)', color2)
}

const curriedShade = curry(shade)

function tint(percentage, color2) {
  return color2 === 'transparent'
    ? color2
    : mix$1(parseFloat(percentage), 'rgb(255, 255, 255)', color2)
}

const curriedTint = curry(tint)

function transparentize(amount, color2) {
  if (color2 === 'transparent') return color2
  const parsedColor = parseToRgb(color2),
    alpha = typeof parsedColor.alpha == 'number' ? parsedColor.alpha : 1,
    colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100),
    })
  return rgba2(colorWithAlpha)
}

const curriedTransparentize = curry(transparentize)

// utils/createTonesFromHues.ts
function createTonesFromHues(hues4) {
  return {
    default: createTintsFromHue(hues4.default, 'Default'),
    primary: createTintsFromHue(hues4.primary, 'Primary'),
    transparent: createTintsFromHue(hues4.transparent, 'Transparent'),
    positive: createTintsFromHue(hues4.positive, 'Positive'),
    caution: createTintsFromHue(hues4.caution, 'Caution'),
    critical: createTintsFromHue(hues4.critical, 'Critical'),
  }
}

function createTintsFromHue(hue, title) {
  let initial = {}
  return COLOR_TINTS2.reduce(
    (acc, tint2) => (
      (acc[tint2] = {
        title: ''.concat(title, ' ').concat(tint2),
        hex: getColorHex(hue, tint2),
      }),
      acc
    ),
    initial,
  )
}

function getColorHex(hue, tint2) {
  let tintNum = Number(tint2),
    midPoint = hue.midPoint,
    darkSize = 1e3 - midPoint,
    lightPosition = tintNum / midPoint,
    darkPosition = (tintNum - midPoint) / darkSize
  return tintNum === midPoint
    ? hue.mid.toLowerCase()
    : tintNum < midPoint
      ? mix$1(lightPosition, hue.mid, hue.lightest)
      : mix$1(darkPosition, hue.darkest, hue.mid)
}

// utils/themeFromHues.ts
function getTint(key) {
  switch (key) {
    case 'blue':
      return blue3
    case 'cyan':
      return cyan3
    case 'gray':
      return gray3
    case 'green':
      return green3
    case 'magenta':
      return magenta3
    case 'orange':
      return orange3
    case 'purple':
      return purple3
    case 'red':
      return red3
    case 'yellow':
      return yellow3
    default:
      throw new Error('Unknown tint: '.concat(key))
  }
}

function themeFromHues({
  hues: partialHues,
  studioTheme: studioTheme2,
  multiply: _multiply,
  screen: _screen,
  parseColor: parseColor3,
  rgbToHex: rgbToHex3,
  rgba: rgba4,
  createColorTheme: createColorTheme2,
}) {
  function multiply3(bg, fg) {
    let b = parseColor3(bg),
      s = parseColor3(fg)
    return rgbToHex3(_multiply(b, s))
  }

  function screen3(bg, fg) {
    let b = parseColor3(bg),
      s = parseColor3(fg)
    return rgbToHex3(_screen(b, s))
  }

  let hues4 = applyHues(partialHues),
    black4 = {title: 'Black', hex: hues4.default.darkest},
    white4 = {title: 'white', hex: hues4.default.lightest},
    tones3 = createTonesFromHues(hues4),
    focusRingHue = tones3.primary,
    accentHue = tones3.critical,
    linkHue = tones3.primary,
    color2 = createColorTheme2({
      base: ({dark, name}) => {
        if (name === 'default') {
          let skeletonFrom2 = dark ? tones3.transparent[900].hex : tones3.transparent[100].hex
          return {
            // @TODO: consider making this overridable
            fg: dark ? white4.hex : black4.hex,
            // @TODO: consider making this overridable
            bg: dark ? black4.hex : white4.hex,
            // @TODO: consider making this overridable
            border: tones3.transparent[dark ? 800 : 200].hex,
            focusRing: focusRingHue[500].hex,
            shadow: {
              outline: rgba4(tones3.transparent[500].hex, 0.4),
              umbra: rgba4(dark ? black4.hex : tones3.transparent[500].hex, 0.2),
              penumbra: rgba4(dark ? black4.hex : tones3.transparent[500].hex, 0.14),
              ambient: rgba4(dark ? black4.hex : tones3.transparent[500].hex, 0.12),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        if (name === 'transparent') {
          let tints2 = tones3.default,
            skeletonFrom2 = tints2[dark ? 800 : 200].hex
          return {
            fg: tints2[dark ? 100 : 900].hex,
            bg: tints2[dark ? 950 : 50].hex,
            border: tints2[dark ? 800 : 300].hex,
            focusRing: focusRingHue[500].hex,
            shadow: {
              outline: rgba4(tints2[500].hex, dark ? 0.2 : 0.4),
              umbra: rgba4(dark ? black4.hex : tints2[500].hex, 0.2),
              penumbra: rgba4(dark ? black4.hex : tints2[500].hex, 0.14),
              ambient: rgba4(dark ? black4.hex : tints2[500].hex, 0.12),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        let tints = tones3[name] || tones3.default,
          skeletonFrom = tints[dark ? 800 : 200].hex
        return {
          fg: tints[dark ? 100 : 900].hex,
          bg: tints[dark ? 950 : 50].hex,
          border: tints[dark ? 800 : 200].hex,
          focusRing: tints[500].hex,
          shadow: {
            outline: rgba4(tints[500].hex, dark ? 0.2 : 0.4),
            umbra: rgba4(dark ? black4.hex : tints[500].hex, 0.2),
            penumbra: rgba4(dark ? black4.hex : tints[500].hex, 0.14),
            ambient: rgba4(dark ? black4.hex : tints[500].hex, 0.12),
          },
          skeleton: {
            from: skeletonFrom,
            to: rgba4(skeletonFrom, 0.5),
          },
        }
      },
      solid: ({base, dark, name, state, tone}) => {
        let mix3 = dark ? screen3 : multiply3,
          mix22 = dark ? multiply3 : screen3,
          defaultTints = tones3[name] || tones3.default,
          isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone),
          tints = tones3[tone === 'default' ? name : tone] || defaultTints
        if (state === 'disabled') {
          tints = defaultTints
          let bg2 = mix3(base.bg, tints[dark ? 800 : 200].hex),
            skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex)
          return {
            bg: bg2,
            bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
            border: mix3(base.bg, tints[dark ? 800 : 200].hex),
            fg: mix3(base.bg, dark ? black4.hex : white4.hex),
            icon: mix3(base.bg, dark ? black4.hex : white4.hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            },
            accent: {
              fg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            },
            link: {
              fg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            },
            code: {
              bg: bg2,
              fg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        if (state === 'hovered') {
          let bg2 = mix3(base.bg, tints[dark ? 300 : 600].hex),
            skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex)
          return {
            bg: bg2,
            bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
            border: mix3(base.bg, tints[dark ? 300 : 600].hex),
            fg: mix3(base.bg, dark ? black4.hex : white4.hex),
            icon: mix3(base.bg, dark ? black4.hex : white4.hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 800 : 200].hex),
            },
            accent: {
              fg: mix22(bg2, accentHue[dark ? 800 : 200].hex),
            },
            link: {
              fg: mix22(bg2, linkHue[dark ? 800 : 200].hex),
            },
            code: {
              bg: mix3(bg2, tints[dark ? 950 : 50].hex),
              fg: mix3(base.bg, tints[dark ? 800 : 200].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        if (state === 'pressed') {
          let bg2 = mix3(base.bg, tints[dark ? 200 : 800].hex),
            skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex)
          return {
            bg: mix3(base.bg, tints[dark ? 200 : 800].hex),
            bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
            border: mix3(base.bg, tints[dark ? 200 : 800].hex),
            fg: mix3(base.bg, dark ? black4.hex : white4.hex),
            icon: mix3(base.bg, dark ? black4.hex : white4.hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 800 : 200].hex),
            },
            accent: {
              fg: mix22(bg2, accentHue[dark ? 800 : 200].hex),
            },
            link: {
              fg: mix22(bg2, linkHue[dark ? 800 : 200].hex),
            },
            code: {
              bg: mix3(bg2, tints[dark ? 950 : 50].hex),
              fg: mix3(base.bg, tints[dark ? 800 : 200].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        if (state === 'selected') {
          isNeutral && (tints = tones3.primary)
          let bg2 = mix3(base.bg, tints[dark ? 200 : 800].hex),
            skeletonFrom2 = mix22(bg2, tints[dark ? 200 : 800].hex)
          return {
            bg: bg2,
            bg2: mix22(bg2, tints[dark ? 50 : 950].hex),
            border: mix3(base.bg, tints[dark ? 200 : 800].hex),
            fg: mix3(base.bg, dark ? black4.hex : white4.hex),
            icon: mix3(base.bg, dark ? black4.hex : white4.hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 800 : 200].hex),
            },
            accent: {
              fg: mix22(bg2, accentHue[dark ? 800 : 200].hex),
            },
            link: {
              fg: mix22(bg2, linkHue[dark ? 800 : 200].hex),
            },
            code: {
              bg: mix3(bg2, tints[dark ? 950 : 50].hex),
              fg: mix3(base.bg, tints[dark ? 800 : 200].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        let bg = mix3(base.bg, tints[dark ? 400 : 500].hex),
          skeletonFrom = mix22(bg, tints[dark ? 200 : 800].hex)
        return {
          bg,
          bg2: mix22(bg, tints[dark ? 50 : 950].hex),
          border: mix3(base.bg, tints[dark ? 400 : 500].hex),
          fg: mix3(base.bg, dark ? black4.hex : white4.hex),
          icon: mix3(base.bg, dark ? black4.hex : white4.hex),
          muted: {
            fg: mix3(base.bg, tints[dark ? 900 : 100].hex),
          },
          accent: {
            fg: mix22(bg, accentHue[dark ? 900 : 100].hex),
          },
          link: {
            fg: mix22(bg, linkHue[dark ? 900 : 100].hex),
          },
          code: {
            bg: mix3(bg, tints[dark ? 950 : 50].hex),
            fg: mix3(base.bg, tints[dark ? 900 : 100].hex),
          },
          skeleton: {
            from: skeletonFrom,
            to: rgba4(skeletonFrom, 0.5),
          },
        }
      },
      muted: ({base, dark, name, state, tone}) => {
        let mix3 = dark ? screen3 : multiply3,
          defaultTints = tones3[name] || tones3.default,
          isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone),
          tints = tones3[tone === 'default' ? name : tone] || defaultTints
        if (state === 'disabled') {
          tints = defaultTints
          let bg2 = base.bg,
            skeletonFrom2 = mix3(bg2, tints[dark ? 900 : 100].hex)
          return {
            bg: bg2,
            bg2: mix3(bg2, tints[dark ? 950 : 50].hex),
            border: mix3(bg2, tints[dark ? 950 : 50].hex),
            fg: mix3(bg2, tints[dark ? 800 : 200].hex),
            icon: mix3(bg2, tints[dark ? 800 : 200].hex),
            muted: {
              fg: mix3(bg2, tints[dark ? 900 : 100].hex),
            },
            accent: {
              fg: mix3(bg2, tints[dark ? 900 : 100].hex),
            },
            link: {
              fg: mix3(bg2, tints[dark ? 900 : 100].hex),
            },
            code: {
              bg: bg2,
              fg: mix3(bg2, tints[dark ? 900 : 100].hex),
            },
            skeleton: {
              from: rgba4(skeletonFrom2, 0.5),
              to: rgba4(skeletonFrom2, 0.25),
            },
          }
        }
        if (state === 'hovered') {
          isNeutral && (tints = tones3.primary)
          let bg2 = mix3(base.bg, tints[dark ? 950 : 50].hex),
            skeletonFrom2 = mix3(bg2, tints[dark ? 900 : 100].hex)
          return {
            bg: bg2,
            bg2: mix3(bg2, tints[dark ? 950 : 50].hex),
            border: mix3(bg2, tints[dark ? 900 : 100].hex),
            fg: mix3(base.bg, tints[dark ? 200 : 800].hex),
            icon: mix3(base.bg, tints[dark ? 200 : 800].hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            },
            accent: {
              fg: mix3(base.bg, linkHue[dark ? 400 : 500].hex),
            },
            link: {
              fg: mix3(base.bg, linkHue[dark ? 400 : 600].hex),
            },
            code: {
              bg: mix3(bg2, tints[dark ? 950 : 50].hex),
              fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        if (state === 'pressed') {
          isNeutral && (tints = tones3.primary)
          let bg2 = mix3(base.bg, tints[dark ? 900 : 100].hex),
            skeletonFrom2 = mix3(bg2, tints[dark ? 900 : 100].hex)
          return {
            bg: bg2,
            bg2: mix3(bg2, tints[dark ? 950 : 50].hex),
            border: mix3(bg2, tints[dark ? 900 : 100].hex),
            fg: mix3(base.bg, tints[dark ? 200 : 800].hex),
            icon: mix3(base.bg, tints[dark ? 200 : 800].hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            },
            accent: {
              fg: mix3(bg2, accentHue[dark ? 400 : 500].hex),
            },
            link: {
              fg: mix3(bg2, linkHue[dark ? 400 : 600].hex),
            },
            code: {
              bg: mix3(bg2, tints[dark ? 950 : 50].hex),
              fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        if (state === 'selected') {
          isNeutral && (tints = tones3.primary)
          let bg2 = mix3(base.bg, tints[dark ? 900 : 100].hex),
            skeletonFrom2 = mix3(bg2, tints[dark ? 900 : 100].hex)
          return {
            bg: bg2,
            bg2: mix3(bg2, tints[dark ? 950 : 50].hex),
            border: mix3(bg2, tints[dark ? 900 : 100].hex),
            fg: mix3(base.bg, tints[dark ? 200 : 800].hex),
            icon: mix3(base.bg, tints[dark ? 200 : 800].hex),
            muted: {
              fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            },
            accent: {
              fg: mix3(bg2, accentHue[dark ? 400 : 500].hex),
            },
            link: {
              fg: mix3(bg2, linkHue[dark ? 400 : 600].hex),
            },
            code: {
              bg: mix3(bg2, tints[dark ? 950 : 50].hex),
              fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            },
            skeleton: {
              from: skeletonFrom2,
              to: rgba4(skeletonFrom2, 0.5),
            },
          }
        }
        let bg = base.bg,
          skeletonFrom = mix3(bg, tints[dark ? 900 : 100].hex)
        return {
          bg,
          bg2: mix3(bg, tints[dark ? 950 : 50].hex),
          border: mix3(bg, tints[dark ? 900 : 100].hex),
          fg: mix3(base.bg, tints[dark ? 300 : 700].hex),
          icon: mix3(base.bg, tints[dark ? 300 : 700].hex),
          muted: {
            fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
          },
          accent: {
            fg: mix3(base.bg, accentHue[dark ? 400 : 500].hex),
          },
          link: {
            fg: mix3(base.bg, linkHue[dark ? 400 : 600].hex),
          },
          code: {
            bg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
          },
          skeleton: {
            from: skeletonFrom,
            to: rgba4(skeletonFrom, 0.5),
          },
        }
      },
      button: ({base, mode, muted, solid}) =>
        mode === 'bleed'
          ? {
              enabled: {
                ...muted.enabled,
                border: muted.enabled.bg,
              },
              hovered: {
                ...muted.hovered,
                border: muted.hovered.bg,
              },
              pressed: {
                ...muted.pressed,
                border: muted.pressed.bg,
              },
              selected: {
                ...muted.selected,
                border: muted.selected.bg,
              },
              disabled: {
                ...muted.disabled,
                border: muted.disabled.bg,
              },
            }
          : mode === 'ghost'
            ? {
                ...solid,
                enabled: {
                  ...muted.enabled,
                  border: base.border,
                },
                disabled: muted.disabled,
              }
            : solid,
      card: ({base, dark, muted, name, solid, state}) => {
        if (state === 'hovered') return muted[name].hovered
        if (state === 'disabled') return muted[name].disabled
        let isNeutral = NEUTRAL_TONES.includes(name),
          tints = tones3[name] || tones3.default,
          mix3 = dark ? screen3 : multiply3
        if (state === 'pressed') return isNeutral ? muted.primary.pressed : muted[name].pressed
        if (state === 'selected') return isNeutral ? solid.primary.enabled : solid[name].enabled
        let bg = base.bg,
          skeletonFrom = mix3(base.bg, tints[dark ? 900 : 100].hex)
        return {
          bg,
          bg2: mix3(bg, tints[dark ? 950 : 50].hex),
          fg: base.fg,
          icon: base.fg,
          border: base.border,
          muted: {
            fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
          },
          accent: {
            fg: mix3(base.bg, red3[dark ? 400 : 500].hex),
          },
          link: {
            fg: mix3(base.bg, blue3[dark ? 400 : 600].hex),
          },
          code: {
            bg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            fg: tints[dark ? 400 : 600].hex,
          },
          skeleton: {
            from: skeletonFrom,
            to: rgba4(skeletonFrom, 0.5),
          },
        }
      },
      input: ({base, dark, mode, state}) => {
        let mix3 = dark ? screen3 : multiply3
        if (mode === 'invalid') {
          let tints = tones3.critical
          return {
            bg: mix3(base.bg, tints[dark ? 950 : 50].hex),
            bg2: mix3(base.bg, tints[dark ? 800 : 200].hex),
            fg: mix3(base.bg, tints[dark ? 400 : 600].hex),
            border: mix3(base.bg, tints[dark ? 800 : 200].hex),
            placeholder: mix3(base.bg, tints[dark ? 600 : 400].hex),
          }
        }
        return state === 'hovered'
          ? {
              bg: base.bg,
              bg2: mix3(base.bg, gray3[dark ? 700 : 300].hex),
              fg: base.fg,
              border: mix3(base.bg, gray3[dark ? 700 : 300].hex),
              placeholder: mix3(base.bg, gray3[dark ? 600 : 400].hex),
            }
          : state === 'disabled'
            ? {
                bg: mix3(base.bg, gray3[dark ? 950 : 50].hex),
                bg2: mix3(base.bg, gray3[dark ? 900 : 100].hex),
                fg: mix3(base.bg, gray3[dark ? 700 : 300].hex),
                border: mix3(base.bg, gray3[dark ? 900 : 100].hex),
                placeholder: mix3(base.bg, gray3[dark ? 800 : 200].hex),
              }
            : state === 'readOnly'
              ? {
                  bg: mix3(base.bg, gray3[dark ? 950 : 50].hex),
                  bg2: mix3(base.bg, gray3[dark ? 800 : 200].hex),
                  fg: mix3(base.bg, gray3[dark ? 200 : 800].hex),
                  border: mix3(base.bg, gray3[dark ? 800 : 200].hex),
                  placeholder: mix3(base.bg, gray3[dark ? 600 : 400].hex),
                }
              : {
                  bg: base.bg,
                  bg2: base.border,
                  fg: base.fg,
                  border: base.border,
                  placeholder: mix3(base.bg, gray3[dark ? 600 : 400].hex),
                }
      },
      selectable: ({base, muted, tone, solid, state}) =>
        state === 'enabled'
          ? {
              ...muted[tone].enabled,
              bg: base.bg,
            }
          : state === 'pressed'
            ? tone === 'default'
              ? muted.primary.pressed
              : muted[tone].pressed
            : state === 'selected'
              ? tone === 'default'
                ? solid.primary.enabled
                : solid[tone].enabled
              : state === 'disabled'
                ? {
                    ...muted[tone].disabled,
                    bg: base.bg,
                  }
                : muted[tone][state],
      spot: ({base, dark, key}) =>
        (dark ? screen3 : multiply3)(base.bg, getTint(key)[dark ? 400 : 500].hex),
      syntax: ({base, dark}) => {
        let mix3 = dark ? screen3 : multiply3,
          mainShade = dark ? 400 : 600,
          secondaryShade = dark ? 600 : 400
        return {
          atrule: mix3(base.bg, purple3[mainShade].hex),
          attrName: mix3(base.bg, green3[mainShade].hex),
          attrValue: mix3(base.bg, yellow3[mainShade].hex),
          attribute: mix3(base.bg, yellow3[mainShade].hex),
          boolean: mix3(base.bg, purple3[mainShade].hex),
          builtin: mix3(base.bg, purple3[mainShade].hex),
          cdata: mix3(base.bg, yellow3[mainShade].hex),
          char: mix3(base.bg, yellow3[mainShade].hex),
          class: mix3(base.bg, orange3[mainShade].hex),
          className: mix3(base.bg, cyan3[mainShade].hex),
          comment: mix3(base.bg, gray3[secondaryShade].hex),
          constant: mix3(base.bg, purple3[mainShade].hex),
          deleted: mix3(base.bg, red3[mainShade].hex),
          doctype: mix3(base.bg, gray3[secondaryShade].hex),
          entity: mix3(base.bg, red3[mainShade].hex),
          function: mix3(base.bg, green3[mainShade].hex),
          hexcode: mix3(base.bg, blue3[mainShade].hex),
          id: mix3(base.bg, purple3[mainShade].hex),
          important: mix3(base.bg, purple3[mainShade].hex),
          inserted: mix3(base.bg, yellow3[mainShade].hex),
          keyword: mix3(base.bg, magenta3[mainShade].hex),
          number: mix3(base.bg, purple3[mainShade].hex),
          operator: mix3(base.bg, magenta3[mainShade].hex),
          prolog: mix3(base.bg, gray3[secondaryShade].hex),
          property: mix3(base.bg, blue3[mainShade].hex),
          pseudoClass: mix3(base.bg, yellow3[mainShade].hex),
          pseudoElement: mix3(base.bg, yellow3[mainShade].hex),
          punctuation: mix3(base.bg, gray3[mainShade].hex),
          regex: mix3(base.bg, blue3[mainShade].hex),
          selector: mix3(base.bg, red3[mainShade].hex),
          string: mix3(base.bg, yellow3[mainShade].hex),
          symbol: mix3(base.bg, purple3[mainShade].hex),
          tag: mix3(base.bg, red3[mainShade].hex),
          unit: mix3(base.bg, orange3[mainShade].hex),
          url: mix3(base.bg, red3[mainShade].hex),
          variable: mix3(base.bg, red3[mainShade].hex),
        }
      },
    })
  return {...studioTheme2, color: color2, __themer: !0, v2: void 0}
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/lib/color-fns/blend/multiply.ts
function multiplyChannel2(b, s) {
  return b * s
}

function multiply2(b, s) {
  return {
    r: multiplyChannel2(b.r / 255, s.r / 255) * 255,
    g: multiplyChannel2(b.g / 255, s.g / 255) * 255,
    b: multiplyChannel2(b.b / 255, s.b / 255) * 255,
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/lib/color-fns/blend/screen.ts
function screenChannel2(b, s) {
  return b + s - b * s
}

function screen2(b, s) {
  return {
    r: screenChannel2(b.r / 255, s.r / 255) * 255,
    g: screenChannel2(b.g / 255, s.g / 255) * 255,
    b: screenChannel2(b.b / 255, s.b / 255) * 255,
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/lib/utils.ts
function clamp2(a, min = 0, max = 1) {
  return Math.min(max, Math.max(min, a))
}

function round2(value) {
  return Math.round(value)
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/lib/color-fns/convert.ts
function hexToRgb2(hex) {
  if (hex.length === 4) {
    let hexR = hex.slice(1, 2),
      hexG = hex.slice(2, 3),
      hexB = hex.slice(3, 4)
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16),
    }
  }
  return {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16),
  }
}

function rgbaToRGBA2(rgba4) {
  let values = rgba4.replace(/rgba\(|\)/g, '').split(',')
  return {
    r: parseInt(values[0]),
    g: parseInt(values[1]),
    b: parseInt(values[2]),
    a: parseFloat(values[3]),
  }
}

function rgbToHex2(color2) {
  let r = round2(clamp2(Math.round(color2.r), 0, 255)),
    g = round2(clamp2(Math.round(color2.g), 0, 255)),
    b = round2(clamp2(Math.round(color2.b), 0, 255))
  return 'a' in color2
    ? 'rgba('.concat(r, ',').concat(g, ',').concat(b, ',').concat(color2.a, ')')
    : '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
}

function hslToRgb3(hsl2) {
  let s = hsl2.s / 100,
    l = hsl2.l / 100,
    c = (1 - Math.abs(2 * l - 1)) * s,
    x = c * (1 - Math.abs(((hsl2.h / 60) % 2) - 1)),
    m = l - c / 2,
    r = 0,
    g = 0,
    b = 0
  return (
    0 <= hsl2.h && hsl2.h < 60
      ? ((r = c), (g = x), (b = 0))
      : 60 <= hsl2.h && hsl2.h < 120
        ? ((r = x), (g = c), (b = 0))
        : 120 <= hsl2.h && hsl2.h < 180
          ? ((r = 0), (g = c), (b = x))
          : 180 <= hsl2.h && hsl2.h < 240
            ? ((r = 0), (g = x), (b = c))
            : 240 <= hsl2.h && hsl2.h < 300
              ? ((r = x), (g = 0), (b = c))
              : 300 <= hsl2.h && hsl2.h < 360 && ((r = c), (g = 0), (b = x)),
    {
      r: Math.round((r + m) * 255),
      g: Math.round((g + m) * 255),
      b: Math.round((b + m) * 255),
    }
  )
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/lib/color-fns/parse.ts
const HEX_CHARS2 = '0123456789ABCDEFabcdef',
  HSL_RE2 = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i

function isHexChars2(str) {
  for (let c of str) if (HEX_CHARS2.indexOf(c) === -1) return !1
  return !0
}

function isHex2(str) {
  return str[0] !== '#' || !(str.length === 4 || str.length === 7) ? !1 : isHexChars2(str.slice(1))
}

function parseHsl2(str) {
  let res = HSL_RE2.exec(str)
  if (!res) throw new Error('parseHsl: string is not a HSL color: "'.concat(str, '"'))
  return {h: parseInt(res[1]), s: parseFloat(res[3]), l: parseFloat(res[5])}
}

function parseColor2(color2) {
  if (!color2) return {r: 0, g: 0, b: 0}
  if (typeof color2 != 'string') throw new Error('parseColor: expected a string')
  if (isHex2(color2)) return hexToRgb2(color2)
  if (color2.startsWith('hsl(')) return hslToRgb3(parseHsl2(color2))
  if (color2.startsWith('rgba(')) return rgbaToRGBA2(color2)
  throw new Error('parseColor: unexpected color format: "'.concat(color2, '"'))
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/lib/color-fns/rgba.ts
function rgba3(color2, a) {
  let rgb2 = parseColor2(color2)
  return 'rgba('.concat(rgb2.r, ',').concat(rgb2.g, ',').concat(rgb2.b, ',').concat(a, ')')
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/_selectable/createSelectableTones.ts
function createSelectableTones(opts, base, dark, solid, muted) {
  return {
    default: _createSelectableStates(opts, base, dark, solid, muted, 'default'),
    primary: _createSelectableStates(opts, base, dark, solid, muted, 'primary'),
    positive: _createSelectableStates(opts, base, dark, solid, muted, 'positive'),
    caution: _createSelectableStates(opts, base, dark, solid, muted, 'caution'),
    critical: _createSelectableStates(opts, base, dark, solid, muted, 'critical'),
  }
}

function _createSelectableStates(opts, base, dark, solid, muted, tone) {
  return {
    enabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: 'enabled',
      tone,
    }),
    hovered: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: 'hovered',
      tone,
    }),
    pressed: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: 'pressed',
      tone,
    }),
    selected: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: 'selected',
      tone,
    }),
    disabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: 'disabled',
      tone,
    }),
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/_solid/createSolidTones.ts
function createSolidTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.solid({base, dark, tone: 'default', name, state: 'enabled'}),
      disabled: opts.solid({base, dark, tone: 'default', name, state: 'disabled'}),
      hovered: opts.solid({base, dark, tone: 'default', name, state: 'hovered'}),
      pressed: opts.solid({base, dark, tone: 'default', name, state: 'pressed'}),
      selected: opts.solid({base, dark, tone: 'default', name, state: 'selected'}),
    },
    transparent: {
      enabled: opts.solid({base, dark, tone: 'transparent', name, state: 'enabled'}),
      disabled: opts.solid({base, dark, tone: 'transparent', name, state: 'disabled'}),
      hovered: opts.solid({base, dark, tone: 'transparent', name, state: 'hovered'}),
      pressed: opts.solid({base, dark, tone: 'transparent', name, state: 'pressed'}),
      selected: opts.solid({base, dark, tone: 'transparent', name, state: 'selected'}),
    },
    primary: {
      enabled: opts.solid({base, dark, tone: 'primary', name, state: 'enabled'}),
      disabled: opts.solid({base, dark, tone: 'primary', name, state: 'disabled'}),
      hovered: opts.solid({base, dark, tone: 'primary', name, state: 'hovered'}),
      pressed: opts.solid({base, dark, tone: 'primary', name, state: 'pressed'}),
      selected: opts.solid({base, dark, tone: 'primary', name, state: 'selected'}),
    },
    positive: {
      enabled: opts.solid({base, dark, tone: 'positive', name, state: 'enabled'}),
      disabled: opts.solid({base, dark, tone: 'positive', name, state: 'disabled'}),
      hovered: opts.solid({base, dark, tone: 'positive', name, state: 'hovered'}),
      pressed: opts.solid({base, dark, tone: 'positive', name, state: 'pressed'}),
      selected: opts.solid({base, dark, tone: 'positive', name, state: 'selected'}),
    },
    caution: {
      enabled: opts.solid({base, dark, tone: 'caution', name, state: 'enabled'}),
      disabled: opts.solid({base, dark, tone: 'caution', name, state: 'disabled'}),
      hovered: opts.solid({base, dark, tone: 'caution', name, state: 'hovered'}),
      pressed: opts.solid({base, dark, tone: 'caution', name, state: 'pressed'}),
      selected: opts.solid({base, dark, tone: 'caution', name, state: 'selected'}),
    },
    critical: {
      enabled: opts.solid({base, dark, tone: 'critical', name, state: 'enabled'}),
      disabled: opts.solid({base, dark, tone: 'critical', name, state: 'disabled'}),
      hovered: opts.solid({base, dark, tone: 'critical', name, state: 'hovered'}),
      pressed: opts.solid({base, dark, tone: 'critical', name, state: 'pressed'}),
      selected: opts.solid({base, dark, tone: 'critical', name, state: 'selected'}),
    },
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/button/createButtonTones.ts
function createButtonTones(opts, base, dark, solid, muted, mode) {
  return {
    default: opts.button({
      base,
      dark,
      solid: solid.default,
      muted: muted.default,
      mode,
    }),
    primary: opts.button({
      base,
      dark,
      solid: solid.primary,
      muted: muted.primary,
      mode,
    }),
    positive: opts.button({
      base,
      dark,
      solid: solid.positive,
      muted: muted.positive,
      mode,
    }),
    caution: opts.button({
      base,
      dark,
      solid: solid.caution,
      muted: muted.caution,
      mode,
    }),
    critical: opts.button({
      base,
      dark,
      solid: solid.critical,
      muted: muted.critical,
      mode,
    }),
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/button/createButtonModes.ts
function createButtonModes(opts, base, dark, solid, muted) {
  return {
    default: createButtonTones(opts, base, dark, solid, muted, 'default'),
    ghost: createButtonTones(opts, base, dark, solid, muted, 'ghost'),
    bleed: createButtonTones(opts, base, dark, solid, muted, 'bleed'),
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/card/createCardStates.ts
function createCardStates(opts, base, dark, name, solid, muted) {
  return {
    enabled: opts.card({
      base,
      dark,
      name,
      state: 'enabled',
      solid,
      muted,
    }),
    disabled: opts.card({
      base,
      dark,
      name,
      state: 'disabled',
      solid,
      muted,
    }),
    hovered: opts.card({
      base,
      dark,
      name,
      state: 'hovered',
      solid,
      muted,
    }),
    pressed: opts.card({
      base,
      dark,
      name,
      state: 'pressed',
      solid,
      muted,
    }),
    selected: opts.card({
      base,
      dark,
      name,
      state: 'selected',
      solid,
      muted,
    }),
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/defaults.ts
const black3 = 'hsl(0, 0%, 0%)',
  white3 = 'hsl(0, 0%, 100%)',
  colors2 = {
    default: {
      lightest: 'hsl(0, 0%, 95%)',
      lighter: 'hsl(0, 0%, 70%)',
      light: 'hsl(0, 0%, 65%)',
      base: 'hsl(0, 0%, 50%)',
      dark: 'hsl(0, 0%, 35%)',
      darker: 'hsl(0, 0%, 20%)',
      darkest: 'hsl(0, 0%, 5%)',
    },
    transparent: {
      lightest: 'hsl(240, 100%, 95%)',
      lighter: 'hsl(240, 100%, 70%)',
      light: 'hsl(240, 100%, 65%)',
      base: 'hsl(240, 100%, 50%)',
      dark: 'hsl(240, 100%, 35%)',
      darker: 'hsl(240, 100%, 20%)',
      darkest: 'hsl(240, 100%, 5%)',
    },
    primary: {
      lightest: 'hsl(240, 100%, 95%)',
      lighter: 'hsl(240, 100%, 70%)',
      light: 'hsl(240, 100%, 65%)',
      base: 'hsl(240, 100%, 50%)',
      dark: 'hsl(240, 100%, 35%)',
      darker: 'hsl(240, 100%, 20%)',
      darkest: 'hsl(240, 100%, 5%)',
    },
    positive: {
      lightest: 'hsl(120, 100%, 95%)',
      lighter: 'hsl(120, 100%, 70%)',
      light: 'hsl(120, 100%, 65%)',
      base: 'hsl(120, 100%, 50%)',
      dark: 'hsl(120, 100%, 35%)',
      darker: 'hsl(120, 100%, 20%)',
      darkest: 'hsl(120, 100%, 5%)',
    },
    caution: {
      lightest: 'hsl(60, 100%, 95%)',
      lighter: 'hsl(60, 100%, 70%)',
      light: 'hsl(60, 100%, 65%)',
      base: 'hsl(60, 100%, 50%)',
      dark: 'hsl(60, 100%, 35%)',
      darker: 'hsl(60, 100%, 20%)',
      darkest: 'hsl(60, 100%, 5%)',
    },
    critical: {
      lightest: 'hsl(0, 100%, 95%)',
      lighter: 'hsl(0, 100%, 70%)',
      light: 'hsl(0, 100%, 65%)',
      base: 'hsl(0, 100%, 50%)',
      dark: 'hsl(0, 100%, 35%)',
      darker: 'hsl(0, 100%, 20%)',
      darkest: 'hsl(0, 100%, 5%)',
    },
  },
  spots = {
    gray: 'hsl(0, 0%, 50%)',
    red: 'hsl(0, 100%, 50%)',
    orange: 'hsl(30, 100%, 50%)',
    yellow: 'hsl(60, 100%, 50%)',
    green: 'hsl(120, 100%, 50%)',
    cyan: 'hsl(180, 100%, 50%)',
    blue: 'hsl(240, 100%, 50%)',
    purple: 'hsl(270, 100%, 50%)',
    magenta: 'hsl(300, 100%, 50%)',
  },
  tones2 = {
    transparent: {
      bg: [colors2.transparent.darkest, colors2.transparent.lightest],
      fg: [colors2.transparent.lightest, colors2.transparent.darkest],
      border: [colors2.transparent.darker, colors2.transparent.lighter],
      focusRing: [colors2.transparent.base, colors2.transparent.base],
    },
    primary: {
      bg: [colors2.primary.darkest, colors2.primary.lightest],
      fg: [colors2.primary.lightest, colors2.primary.darkest],
      border: [colors2.primary.darker, colors2.primary.lighter],
      focusRing: [colors2.primary.base, colors2.primary.base],
    },
    positive: {
      bg: [colors2.positive.darkest, colors2.positive.lightest],
      fg: [colors2.positive.lightest, colors2.positive.darkest],
      border: [colors2.positive.darker, colors2.positive.lighter],
      focusRing: [colors2.positive.base, colors2.positive.base],
    },
    caution: {
      bg: [colors2.caution.darkest, colors2.caution.lightest],
      fg: [colors2.caution.lightest, colors2.caution.darkest],
      border: [colors2.caution.darker, colors2.caution.lighter],
      focusRing: [colors2.caution.base, colors2.caution.base],
    },
    critical: {
      bg: [colors2.critical.darkest, colors2.critical.lightest],
      fg: [colors2.critical.lightest, colors2.critical.darkest],
      border: [colors2.critical.darker, colors2.critical.lighter],
      focusRing: [colors2.critical.base, colors2.critical.base],
    },
  },
  defaultOpts = {
    base: ({dark, name}) =>
      name === 'default'
        ? {
            bg: dark ? black3 : white3,
            fg: dark ? white3 : black3,
            border: dark ? colors2.default.darkest : colors2.default.lightest,
            focusRing: colors2.primary.base,
            shadow: {
              outline: black3,
              umbra: black3,
              penumbra: black3,
              ambient: black3,
            },
            skeleton: {
              from: dark ? white3 : black3,
              to: dark ? white3 : black3,
            },
          }
        : {
            bg: tones2[name].bg[dark ? 0 : 1],
            fg: tones2[name].fg[dark ? 0 : 1],
            border: tones2[name].border[dark ? 0 : 1],
            focusRing: tones2[name].focusRing[dark ? 0 : 1],
            shadow: {
              outline: black3,
              umbra: black3,
              penumbra: black3,
              ambient: black3,
            },
            skeleton: {
              from: dark ? white3 : black3,
              to: dark ? white3 : black3,
            },
          },
    solid: ({base, dark, state, tone}) => {
      let color2 = colors2[tone]
      return state === 'hovered'
        ? {
            bg: dark ? color2.light : color2.dark,
            bg2: dark ? color2.light : color2.dark,
            border: dark ? color2.lighter : color2.darker,
            fg: dark ? color2.darkest : color2.lightest,
            icon: dark ? color2.darkest : color2.lightest,
            muted: {
              fg: black3,
            },
            accent: {
              fg: black3,
            },
            link: {
              fg: black3,
            },
            code: {
              bg: black3,
              fg: black3,
            },
            skeleton: base.skeleton,
          }
        : {
            bg: color2.base,
            bg2: color2.base,
            border: dark ? color2.light : color2.dark,
            fg: dark ? color2.darkest : color2.lightest,
            icon: dark ? color2.darkest : color2.lightest,
            muted: {
              fg: black3,
            },
            accent: {
              fg: black3,
            },
            link: {
              fg: black3,
            },
            code: {
              bg: black3,
              fg: black3,
            },
            skeleton: base.skeleton,
          }
    },
    muted: ({base, dark, state, tone}) => {
      let color2 = colors2[tone]
      return state === 'hovered'
        ? {
            bg: dark ? color2.darker : color2.lighter,
            bg2: dark ? color2.darker : color2.lighter,
            border: dark ? color2.lighter : color2.darker,
            fg: dark ? color2.lightest : color2.darkest,
            icon: dark ? color2.lightest : color2.darkest,
            muted: {
              fg: black3,
            },
            accent: {
              fg: black3,
            },
            link: {
              fg: black3,
            },
            code: {
              bg: black3,
              fg: black3,
            },
            skeleton: base.skeleton,
          }
        : {
            bg: dark ? color2.darkest : color2.lightest,
            bg2: dark ? color2.darkest : color2.lightest,
            border: dark ? color2.darker : color2.lighter,
            fg: dark ? color2.lighter : color2.darker,
            icon: dark ? color2.lighter : color2.darker,
            muted: {
              fg: black3,
            },
            accent: {
              fg: black3,
            },
            link: {
              fg: black3,
            },
            code: {
              bg: black3,
              fg: black3,
            },
            skeleton: base.skeleton,
          }
    },
    button: ({base, mode, muted, solid}) =>
      mode === 'bleed'
        ? {
            ...muted,
            enabled: {
              bg: 'transparent',
              bg2: 'transparent',
              fg: muted.enabled.fg,
              icon: muted.enabled.fg,
              border: 'transparent',
              muted: {
                fg: black3,
              },
              accent: {
                fg: black3,
              },
              link: {
                fg: black3,
              },
              code: {
                bg: black3,
                fg: black3,
              },
              skeleton: base.skeleton,
            },
            hovered: {
              bg: muted.enabled.bg,
              bg2: muted.enabled.bg,
              fg: muted.hovered.fg,
              icon: muted.hovered.fg,
              border: 'transparent',
              muted: {
                fg: black3,
              },
              accent: {
                fg: black3,
              },
              link: {
                fg: black3,
              },
              code: {
                bg: black3,
                fg: black3,
              },
              skeleton: base.skeleton,
            },
          }
        : mode === 'ghost'
          ? {
              ...solid,
              enabled: muted.enabled,
            }
          : solid,
    card: ({base}) => ({
      bg: black3,
      bg2: black3,
      fg: black3,
      icon: black3,
      border: black3,
      muted: {
        fg: black3,
      },
      accent: {
        fg: black3,
      },
      link: {
        fg: black3,
      },
      code: {
        bg: black3,
        fg: black3,
      },
      skeleton: base.skeleton,
    }),
    input: () => ({
      bg: black3,
      bg2: black3,
      fg: black3,
      border: black3,
      placeholder: black3,
    }),
    selectable: ({muted, state, tone}) => muted[tone][state],
    spot: ({key}) => spots[key],
    syntax: () => ({
      atrule: black3,
      attrName: black3,
      attrValue: black3,
      attribute: black3,
      boolean: black3,
      builtin: black3,
      cdata: black3,
      char: black3,
      class: black3,
      className: black3,
      comment: black3,
      constant: black3,
      deleted: black3,
      doctype: black3,
      entity: black3,
      function: black3,
      hexcode: black3,
      id: black3,
      important: black3,
      inserted: black3,
      keyword: black3,
      number: black3,
      operator: black3,
      prolog: black3,
      property: black3,
      pseudoClass: black3,
      pseudoElement: black3,
      punctuation: black3,
      regex: black3,
      selector: black3,
      string: black3,
      symbol: black3,
      tag: black3,
      unit: black3,
      url: black3,
      variable: black3,
    }),
  }

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/input/createInputModes.ts
function createInputModes(opts, base, dark, solid, muted) {
  return {
    default: {
      enabled: opts.input({
        base,
        dark,
        mode: 'default',
        state: 'enabled',
        solid: solid.default,
        muted: muted.default,
      }),
      disabled: opts.input({
        base,
        dark,
        mode: 'default',
        state: 'disabled',
        solid: solid.default,
        muted: muted.default,
      }),
      hovered: opts.input({
        base,
        dark,
        mode: 'default',
        state: 'hovered',
        solid: solid.default,
        muted: muted.default,
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: 'default',
        state: 'readOnly',
        solid: solid.default,
        muted: muted.default,
      }),
    },
    invalid: {
      enabled: opts.input({
        base,
        dark,
        mode: 'invalid',
        state: 'enabled',
        solid: solid.default,
        muted: muted.default,
      }),
      disabled: opts.input({
        base,
        dark,
        mode: 'invalid',
        state: 'disabled',
        solid: solid.default,
        muted: muted.default,
      }),
      hovered: opts.input({
        base,
        dark,
        mode: 'invalid',
        state: 'hovered',
        solid: solid.default,
        muted: muted.default,
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: 'invalid',
        state: 'readOnly',
        solid: solid.default,
        muted: muted.default,
      }),
    },
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/muted/createMuted.ts
function createMutedTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.muted({base, dark, tone: 'default', name, state: 'enabled'}),
      disabled: opts.muted({base, dark, tone: 'default', name, state: 'disabled'}),
      hovered: opts.muted({base, dark, tone: 'default', name, state: 'hovered'}),
      pressed: opts.muted({base, dark, tone: 'default', name, state: 'pressed'}),
      selected: opts.muted({base, dark, tone: 'default', name, state: 'selected'}),
    },
    transparent: {
      enabled: opts.muted({base, dark, tone: 'transparent', name, state: 'enabled'}),
      disabled: opts.muted({base, dark, tone: 'transparent', name, state: 'disabled'}),
      hovered: opts.muted({base, dark, tone: 'transparent', name, state: 'hovered'}),
      pressed: opts.muted({base, dark, tone: 'transparent', name, state: 'pressed'}),
      selected: opts.muted({base, dark, tone: 'transparent', name, state: 'selected'}),
    },
    primary: {
      enabled: opts.muted({base, dark, tone: 'primary', name, state: 'enabled'}),
      disabled: opts.muted({base, dark, tone: 'primary', name, state: 'disabled'}),
      hovered: opts.muted({base, dark, tone: 'primary', name, state: 'hovered'}),
      pressed: opts.muted({base, dark, tone: 'primary', name, state: 'pressed'}),
      selected: opts.muted({base, dark, tone: 'primary', name, state: 'selected'}),
    },
    positive: {
      enabled: opts.muted({base, dark, tone: 'positive', name, state: 'enabled'}),
      disabled: opts.muted({base, dark, tone: 'positive', name, state: 'disabled'}),
      hovered: opts.muted({base, dark, tone: 'positive', name, state: 'hovered'}),
      pressed: opts.muted({base, dark, tone: 'positive', name, state: 'pressed'}),
      selected: opts.muted({base, dark, tone: 'positive', name, state: 'selected'}),
    },
    caution: {
      enabled: opts.muted({base, dark, tone: 'caution', name, state: 'enabled'}),
      disabled: opts.muted({base, dark, tone: 'caution', name, state: 'disabled'}),
      hovered: opts.muted({base, dark, tone: 'caution', name, state: 'hovered'}),
      pressed: opts.muted({base, dark, tone: 'caution', name, state: 'pressed'}),
      selected: opts.muted({base, dark, tone: 'caution', name, state: 'selected'}),
    },
    critical: {
      enabled: opts.muted({base, dark, tone: 'critical', name, state: 'enabled'}),
      disabled: opts.muted({base, dark, tone: 'critical', name, state: 'disabled'}),
      hovered: opts.muted({base, dark, tone: 'critical', name, state: 'hovered'}),
      pressed: opts.muted({base, dark, tone: 'critical', name, state: 'pressed'}),
      selected: opts.muted({base, dark, tone: 'critical', name, state: 'selected'}),
    },
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/spot/createSpot.ts
function createSpot(opts, base, dark) {
  return {
    gray: opts.spot({base, dark, key: 'gray'}),
    blue: opts.spot({base, dark, key: 'blue'}),
    purple: opts.spot({base, dark, key: 'purple'}),
    magenta: opts.spot({base, dark, key: 'magenta'}),
    red: opts.spot({base, dark, key: 'red'}),
    orange: opts.spot({base, dark, key: 'orange'}),
    yellow: opts.spot({base, dark, key: 'yellow'}),
    green: opts.spot({base, dark, key: 'green'}),
    cyan: opts.spot({base, dark, key: 'cyan'}),
  }
}

// ../../node_modules/.pnpm/@sanity+ui@2.1.1_react-dom@18.2.0_react-is@18.2.0_react@18.2.0_styled-components@6.1.8/node_modules/@sanity/ui/src/theme/build/_deprecated/color/factory.ts
function createColorTheme(partialOpts = {}) {
  let builders = {...defaultOpts, ...partialOpts}
  return {
    light: _createColorScheme(builders, !1),
    dark: _createColorScheme(builders, !0),
  }
}

function _createColorScheme(opts, dark) {
  return {
    default: _createColor(opts, dark, 'default'),
    transparent: _createColor(opts, dark, 'transparent'),
    primary: _createColor(opts, dark, 'primary'),
    positive: _createColor(opts, dark, 'positive'),
    caution: _createColor(opts, dark, 'caution'),
    critical: _createColor(opts, dark, 'critical'),
  }
}

function _createColor(opts, dark, name) {
  let base = opts.base({dark, name}),
    solid = createSolidTones(opts, base, dark, name),
    muted = createMutedTones(opts, base, dark, name)
  return {
    base,
    button: createButtonModes(opts, base, dark, solid, muted),
    card: createCardStates(opts, base, dark, name, solid, muted),
    dark,
    input: createInputModes(opts, base, dark, solid, muted),
    selectable: createSelectableTones(opts, base, dark, solid, muted),
    spot: createSpot(opts, base, dark),
    syntax: opts.syntax({base, dark}),
    solid,
    muted,
  }
}

// <stdin>
const hues3 = {
    default: {
      lightest: '#fcfdfd',
      darkest: '#0e1315',
      mid: '#678e9a',
      midPoint: 500,
    },
    primary: {
      lightest: '#fcfdfd',
      darkest: '#0e1315',
      mid: '#f13009',
      midPoint: 500,
    },
    transparent: {
      lightest: '#fcfdfd',
      darkest: '#0e1315',
      mid: '#678e9a',
      midPoint: 500,
    },
    positive: {
      lightest: '#fcfdfd',
      darkest: '#0e1315',
      mid: '#43d675',
      midPoint: 300,
    },
    caution: {
      lightest: '#fcfdfd',
      darkest: '#0e1315',
      mid: '#fbd024',
      midPoint: 300,
    },
    critical: {
      lightest: '#fcfdfd',
      darkest: '#0e1315',
      mid: '#f02f35',
      midPoint: 500,
    },
  },
  createTheme = (_hues) =>
    themeFromHues({
      createColorTheme,
      hues: _hues,
      multiply: multiply2,
      parseColor: parseColor2,
      rgba: rgba3,
      rgbToHex: rgbToHex2,
      screen: screen2,
      studioTheme,
    }),
  theme = createTheme(hues3)

export {createTheme, hues3 as hues, theme}
